#运算符
# 运算符
按功能分为九类：
![[Pasted image 20220606215407.png]]
按操作数分为三类
![[Pasted image 20220606215414.png]]

## 算术操作符
双目操作符对 2 个操作数进行算术运算，包括乘 （ * ）、除（/）、加（+）、减（-）、求幂（* * ）、取模（%）。
%要求两侧均为整型数据，
如果操作数**某一位为 X**，则计算结果也会**全部出现 X**。例如：
```verilog
b = 4'b100x ;  
c = a+b ;       //结果为c=4'bxxxx
```
## 逻辑运算符 
把操作数当作bool变量
1. 非0数被认为真（1'b1)
2. 0被认为假
3. 逻辑操作符的计算结果是一个 1bit 的值，0 表示假，1 表示真，x 表示不确定。4'bxx00被认为是不确定，4'bxx11被认为是真，因为肯定是非0.
```verilog
A = 3;  
B = 0;  
C = 2'b1x ;  
     
A && B    //     为假  
A || B    //     为真  
! A       //     为假  
! B       //     为真  
A && C    //     为X，不确定  
A || C    //     为真，因为A为真  
(A==2) && (! B)  //为真，此时第一个操作数为表达式
```
## 关系运算符
关系操作符有大于（>），小于（<），大于等于（>=），小于等于（<=）。
关系操作符的正常结果有 2 种，真（1）或假（0）。
**如果操作数中有一位为 x 或 z，则关系表达式的结果为 x**。

## 等式运算符 

等价操作符包括逻辑相等（== ），逻辑不等（!=），全等（=== ），非全等（! == ）。
等价操作符的正常结果有 2 种：为真（1）或假（0）。
逻辑相等/不等操作符不能比较 x 或 z，当操作数包含一个 x 或 z，则结果为不确定值。
全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1，即全等比较可比较 x 或 z。所以，全等比较的结果一定不包含 x。举例如下：

![[Pasted image 20220606220916.png]]

## 缩减运算符
归约操作符包括：归约与（&），归约与非（~&），归约或（|），归约或非（~|），归约异或（^），归约同或（~^）。
归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 **1bit 结果。**
逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。

![[Pasted image 20220606220948.png]]
## 移位操作符
移位操作符包括左移（<<），右移（>>），算术左移（<<<），算术右移（>>>）。
移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。
算术左移和逻辑左移时，**右边低位会补 0**。
逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。

## 位运算符
按位操作符包括：取反（~），与（&），或（|），异或（^），同或（~^）。
按位操作符对 2 个操作数的每 1bit 数据进行按位操作。
如果 2 个操作数**位宽不相等**，则用 0 向左扩展补充较短的操作数3。0
取反操作符只有一个操作数，它对操作数的每 1bit 数据进行取反操作。

## 拼接操作符
拼接操作符用大括号 {，} 来表示，用于将多个操作数（向量）拼接成新的操作数（向量），信号间用逗号隔开。
拼接符操作数必须**指定位宽**，常数的话也需要指定位宽。否则**默认为32位的二进制数**
可以用重复法简化表达式
![[Pasted image 20220606221605.png]]
例如：
```verilog
A = 4'b1010 ;  
B = 1'b1 ;  
Y1 = {B, A[3:2], A[0], 4'h3 };  //结果为Y1='b1100_0011  
Y2 = {4{B}, 3'd4};  //结果为 Y2=7'b111_1100  
Y3 = {32{1'b0}};  //结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值
```
## 条件操作符

条件表达式有 3 个操作符，结构描述如下：

> condition_expression ? true_expression : false_expression

计算时，如果 condition_expression 为真（逻辑值为 1），则运算结果为 true_expression；如果 condition_expression 为假（逻辑值为 0），则计算结果为 false_expression。
