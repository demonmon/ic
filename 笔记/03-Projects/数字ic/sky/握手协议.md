---
title: 握手协议
date: 2022-08-05 19:22:56
obsidianUIMode: source
---

in_ack : 信号传输开始前是1
```verilog
assign in_ack = (!vld_sync_clk_i) & (!in_vld_lev);
```

din_cap是捕捉信号 传输信号开始与结束,等到in_vld有效din_cap才拉高，但下一个上升沿in_vld_lev也跟着拉高，即in_ack拉低,din_cap也就是产生了脉冲信号。
```verilog
assign din_cap = in_vld & in_ack;
```

in_vld_lev：通过din_cap才能为1，并且等到vld_sync_clk_i_rise脉冲信号有效就结束

```verilog
    always @(posedge clk_i or negedge rstn_i) begin
        if(~rstn_i)
            in_vld_lev <= 1'b0;
        else if (din_cap) begin
            in_vld_lev <=1'b1;
        end
        else if (vld_sync_clk_i_rise)
            in_vld_lev <= 1'b0 ;                        
    end
```

in_vld_lev（电平信号）在clk_o进行打两拍电路（in_vld_clk_o），再加一个脉冲生成电路（in_vld_rise_clk_o）
```verilog
sync_level #(.SYNC_STAGE(SYNC_STAGE)) u_in_vld_sync_clko(
        .din(in_vld_lev),
        .dout(in_vld_clk_o)
        .clk_o(clk_o),
        .rstn_o(rstn_o)
    );
    assign in_vld_rise_clk_o = in_vld_clk_o & (!in_vld_r0_clk_o);
    always @(posedge clk_o or negedge rstn_o) begin   //共三拍
        if(~rstn_o)
            in_vld_r0_clk_o <= 1'b0;
        else
            in_vld_r0_clk_o <= in_vld_clk_o;    
    end
```


这样就把电平信号传到clk_o时钟域，说明可以接收数据,out_ack 是输入，并且此时会在脉冲信号的下一个周期拉高

```verilog
    always @(posedge clk_o or negedge rstn_o) begin
        if(in_vld_rise_clk_o)
            dout <= din_r;
    end
    always @(posedge clk_o or negedge rstn_o ) begin
        if(~rstn_o) begin
            out_vld<=1'b0;
        end
        else if (in_vld_rise_clk_o) begin
            out_vld <= 1'b1;
        end
        else if(out_ack) begin
            out_vld <= 1'b0;
        end
    end
```

![[Pasted image 20220710165116.png]]


然后通过vld_sync同步给源时钟域
```verilog
    always @(posedge clk_o or negedge rstn_o) begin
        if(~rstn_o)
            vld_sync <= 1'b0;
        else if (in_vld_rise_clk_o)
            vld_sync <= 1'b1;
        else if (vld_sync) begin
            if ((!out_vld) && (!in_vld_clk_o)) begin
                vld_sync <= 1'b0;
            end
        end        
    end
    
    
    assign vld_sync_clk_i_rise = vld_sync_clk_i & (! vld_sync_clk_i_r0 );//只产生前面的脉冲
   sync_level #(.SYNC_STAGE(SYNC_STAGE)) u_vld_sync_clk_i(
        .din(vld_sync),
        .dout(vld_sync_clk_i),
        .clk_o(clk_i),
        .rstn_o(rstn_i)
    );
 always @(posedge clk_i or negedge rstn_i) begin
        if(~rstn_i)
            vld_sync_clk_i_r0 <= 1'b0;
        else
            vld_sync_clk_i_r0 <= vld_sync_clk_i;    
    end
    //再打一拍，共三拍
```
![[Pasted image 20220710171221.png]]


然后din_cap 捕获开始下一个数据传输
![[Pasted image 20220710172249.png]]


所以首先是通过电平信号同步到clko转成脉冲信号，此时通过这个脉冲信号进行传输，并且产生同步到clk_i的电平信号sync_vld,拉低通过，invldclko和outvld都是0的时候拉低，然后通过这个信号同步到clki信号，这样就可以再次产生dincap信号。
[跨时钟域处理好文]https://www.cnblogs.com/lyc-seu/p/12441366.html#%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E5%A4%84%E7%90%86--%E6%9C%80%E7%BB%88%E8%AF%A6%E5%B0%BD
![[Pasted image 20220710172949.png]]



其中标明_clk1 的信号表示该信号属于 clk1 时钟域， 同理标明_clk2 的信号表示该信号属于 clk2 时钟域。在两次src_req_clk1 之间被 src_vld_clk1“ 结绳” (pluse2toggle)，在将src_vld_clk1 用双锁存器同步以后， 将该信号转换为 dst_req_clk2(toggle2pluse)。同理，用dst_vld_clk2 将 dst_req_clk2“结绳”， dst_vld_clk2 表明在 clk2 时钟域中， src_dat_clk1 已经可以进行正确采样了。 最后将 dst_vld_clk2 转换为 dst_ack_clk1(synchronizer and toggle2pluse), dst_ack_clk1 表明 src_dat_clk1 已经被 clk2 正确采样了， 此后 clk1 时钟域就可以安全地传输下一个数据了。 可以看出，“结绳法” 关键是将信号结绳以后， 使其保持了足够长的时间，以便另一个时钟可以正确地采样。

![[Pasted image 20220710173247.png]]















