---
title: RTL工具使用
updated: 2022-05-16T14:46:08.0000000+08:00
created: 2022-05-11T14:52:54.0000000+08:00
---

![image1](image1-28.png)

Include test.v 通过incdir目录下找该文件
![image2](image2-25.png)

![image3](image3-22.png)

![image4](image4-20.png)

![[Pasted image 20220609164150.png]]

![image5](image5-17.png)

![image6](image6-14.png)

\<10的情况很简单，直接输出  
问题从10开始。  
10 BIN:1010 BCD:1 0000  
11 BIN:1011 BCD:1 0001  
...  
17 BIN:1 0001 BCD:1 0111  
11等等以后的数差不多，BIN和BCD码差6。
那加上去不就行了？不过，需要确定一下是≥10的。≥10,+6。  
实际上这并不那么理想，因为这只能处理10-19之内的数。  
20 BIN:1 0100 BCD:10 0000  
不过，想想：实际上，在1不会被移到其他4bit区时（在10进制内相当于不进位），整个数左移位就相当于\*2！  
想想看，20可以通过10左移出来。不如，先把它拆解到一个小的数，再移位？  
或者说，直接从0开始移位，一格一格地判断，处理掉≥10，接着移位？如果把后面没加入的位移进去，相当于加上了它！  
梳理一下：  
数向左移，每4bit都判断整合为类BCD  
每一次位移时，1如果不越界，就是完美的\*2！
等等，怎么确保不越界？  
想想看，我们之前处理的时候，4位段决不会被转化为1 1xxx的形式（≥18了）。...不过等等，16呢？17呢？  
完了。（误  
16 BIN:1 0000 BCD:1 0110  
16在移位的时候永远不会出现≥10的片段，但它确实≥10...  
不过，有一个办法：看一下前面，≥10,+6。感觉到了什么吧？  
对，可以优化！≥5,+3，由于只是除以了2，相当于提前了一步判断；也没什么，毕竟10是偶数，忽略的1/0不影响。但是这样子把之前不可用的几个数也给判断出来了。
再次整理一下：将数字向左压入，压入部分从低向高每4位检测是否≥5，如果是则+3一次；接着压。  
注意：完全压入后不要再去判断了，直接输出；因为我们提前了一步。

*来自 \<<https://zhuanlan.zhihu.com/p/130876308>\>*

