## 2. 亚稳态

每一个触发器都有其规定的建立(setup)和保持(hold)时间参数, 在这个时间参数内， 输入信号在时钟的上升沿是不允许发生变的。 如果在信号的建立时间中对其进行采样， 得到的结果将是不可预知的，即亚稳态。

触发器进入亚稳态的时间可以用参数 MTBF(mean time between failures)来描述， MTBF即触发器采样失败的时间间隔，其公式描述如下：

MTBF=etr/τ/T0faMTBF=etr/τ/T0fa

其中：

-   trtr = 分辨时间（时钟沿开始）
-   τ,T0τ,T0 = 触发器参数
-   ff = 采样时钟频率
-   a = 异步事件触发频率

通常，MTBF越大说明系统采样失败的可能越小。可见，对于高速的设计，MTBF是更容易发生的。对于一个典型的 0.25µm 工艺的 ASIC 库中的一个触发器，我们取如下的参数：

tr = 2.3ns, τ = 0.31ns, T0 = 9.6as, f=100MHZ, a = 10MHZ, MTBF = **2.01 days**

也就是说触发器以100MHZ工作，假设异步事件触发的频率，也就是数据变化的频率跟采样时钟频率相同。我们用10MHZ的频率去不停地采它的数据，每个上升沿数据都会发生变化，则每两天就可能采集到一次亚稳态（个人理解，如有误请指正）。如果使用单锁存器同步，b的时钟上升沿采集a的数据时很可能采到亚稳态数据。

![](https://lyc-picture.oss-cn-shanghai.aliyuncs.com/screenshot/20200302172619.png)

![](https://lyc-picture.oss-cn-shanghai.aliyuncs.com/screenshot/20200327201226.png)
### 方法一：双锁存器

为了避免亚稳态，应该使得MTBF尽量大。采用双锁存器可以改善这一问题：

![](https://lyc-picture.oss-cn-shanghai.aliyuncs.com/screenshot/20200302173321.png)

当使用了双锁存器以后， b_dat2 的MTBF由以下公式可以得出：

MTBF=e(tr/τ)/T0fa×e(tr/τ)/T0faMTBF=e(tr/τ)/T0fa×e(tr/τ)/T0fa

如果我们仍然使用上一节所提供的参数，则b_dat2 的MTBF为 **9.57 * 109(years)**。
由上述结果可以看出，双锁存器法可以消除亚稳态问题。
#### 注意问题1

**时钟域B两级同步的寄存器跟时钟域A的输出寄存器之间不能有组合逻辑**。组合逻辑电路各个输入信号的不一致性以及组合逻辑内部路径的延时时间不一样，运算后的信号存在毛刺如图(2),我们无法预先知道CLKB 的上升沿何时会到来，CLKB 采样到的信号就无法预知。 
![[Pasted image 20220715131922.png]]
因此，要想CLKB 能采到稳定的信号，时钟域A的信号必须是经过CLKA 敲过，在一个时钟周期内是稳定的信号，如图（3）所示:
![[Pasted image 20220715131944.png]]


#### 注意问题2

Clock-gating enable 信号没有经过异步处理
![[Pasted image 20220715132124.png]]

在下图中a_in 信号经过CLKA的DFF敲过，再送到两级DFF 同步器处理，完全没毛病。但是F2的使能信号EN是从时钟域A来的，当EN信号变化的时候，由于时钟域不一样，无法保证使能之后的CLKB信号采样数据时满足setup/hold time 要求，这时F2输出信号也就变得无法预测了。因此对clk gating的信号也要做处理。

**也就是说不仅仅数据需要同步，其控制信号也需要同步**

#### 注意问题3

如果较快的时钟域是较慢时钟域频率的1.5倍(或更多)，那么将较慢的控制信号同步到较快的时钟域通常不是问题，因为较快的时钟信号将采样较慢的CDC信号一次或多次。因此将快采慢比慢采快引起的潜在问题更少，所以对于快采慢的情况，使用简单的两个触发器同步器在时钟域之间传递单个Clock Domain Crossing (CDC)信号即可。

而对于慢采快的情况则最好更加稳妥些，一般要求在接收时钟域中采样信号要保持**三个时钟边**沿的时间（"three edge" requirement），也就是1.5倍的采样时钟周期。一般来说1.25倍也够。
如果采样信号维持时间过短，则慢时钟域很可能会漏采：
![[Pasted image 20220715132312.png]]

即使采样信号比采样周期略长，也可能会面临信号改变正好落在时钟沿的setup和hold violation的区域：
![[Pasted image 20220715132329.png]]
解决方案：  
1.开环地控制信号的长度
![[Pasted image 20220715134056.png]]
不需要知道接收时钟域的边沿信息，只要在发送域保证发送信号的长度就可以。


2.闭环控制  
采用反馈信号自动延长快时钟域的信号：
![[Pasted image 20220715134130.png]]
将A时钟域要传输的信号打一拍送到B域中进行双reg同步，同步之后的信号在反馈会A中，A中再进行双reg同步，当A域中反馈同步信号变为高时才将被采信号拉低，这样的方法时比较稳妥的，但是会有更多的延时，并且需要更多同步reg。 例如下图就是采用闭环延长信号的一个方法：

![[Pasted image 20220715134332.png]]
FF1由源时钟驱动，输入变高，FF1输出变高。FF1的Q输出反馈通过与门和或门保证了在FF5输出为0时，只要FF1输出变高，FF1输出就一直保持高。直到FF3同步输出变成1后，FF5输出变成1，与门输出0。这时只要输入为0，FF1输出即为0
### 扩展*

同样一个快时钟域的脉冲信号，其宽度只有快时钟域的**一个周期的长度**，现在需要将该信号同步到一个相对较慢的时钟域，**如果要求不能在快时钟域将脉冲信号展宽，并且同样采用双寄存器同步，该如何实现？**  
下面的这个电路可以解决这一问题：
![[Pasted image 20220715135250.png]]

这个电路跟异步复位同步释放很像，其原理是通过把要处理的异步脉冲当作第一个DFF的时钟输入，这样当有脉冲时该级会拉高，之后后面两级同步器检测到后将第一个DFF置位，这样第一个DFF就置为0，后级之后也变为0. 这种同步器的好处在于不需要再源时钟域对信号做处理，但是缺点也很明显，因为需要将信号作为时钟，会消耗额外的时钟资源，并且该信号的毛刺会导致不可预知的错误。 所以上面这种同步器实际上不推荐使用。还是老老实实展宽脉冲吧。

## 4.多比特同步策略

经常会遇到多个比特的控制信号或者数据信号跨时钟域传输的问题，解决这类问题的出发点主要有：
-   尽可能将这些信号合并成单bit
-   Multi-cycle path （MCP). 使用同步信号。
-   使用Gray码

### 控制信号多比特同步

#### 同步变化的控制信号

例如下面的例子，load和en作为两个控制信号需要跨时钟同步。两个信号可能需要同时拉高才能正确操作，但是实际同步时可能两者存在一定skew，导致再同步域两级reg同步后两个信号错开，导致控制失败：
![[Pasted image 20220715135725.png]]

这种解决办法也很简单，只要将他们合并成一个即可：
![[Pasted image 20220715135743.png]]

#### 控制信号多比特之间有一定时钟相位差

这种情况下，如果两个信号隔开固定的相位，在传输过程中可能会有一定偏移，则同步时也会导致下面的问题： 
![[Pasted image 20220715135803.png]]

可见，ld2信号和ld1信号的相位间隔被改变了，而这通常不是我们希望的。解决办法是只传输其中一个信号，另一个信号在同步域内产生。例如上面的例子可以将ld1在B时钟域通过ld1打一拍得到：
![[Pasted image 20220715135828.png]]




### 数据多比特同步

在数据的多比特传输时更要注意skew的问题，如果bit之间有skew，则传输值很可能出错：![[Pasted image 20220715135909.png]]
主要有两类解决方法： 1. Multi-Cycle Path (MCP) formulation 多周期路径规划（名字怪怪的，感觉就是握手机制） 2. FIFO


#### 方法一：脉冲同步法（开环的结绳法）

首先用到的一个电路是脉冲产生电路：
![[Pasted image 20220715140011.png]]
一个典型的脉冲同步器用于信号同步的例子：

![[Pasted image 20220715140027.png]]
或者还有另一个版本更加清楚一些：
![[Pasted image 20220715140052.png]]
脉冲同步器的工作方式如下：
1.  在A时钟域产生一组单周期脉冲，其间隔至少需要比B时钟域的**两个**时钟周期大，否则B中无法进行边沿检测。同时这组脉冲也表示了A中数据传送的开始和结束。
2.  在A时钟域中，两个脉冲被电平翻转器（**可以由异或门或者mux+inv构成**）将脉冲之间的区域变为一段高电平（结绳toggle)
3.  A中的结绳信号在B中通过边沿产生器翻译为两个单周期脉冲
4.  B中需要由逻辑去监测脉冲并进行信号的采样

#### 方法二：闭环结绳法

上面的脉冲同步信号实际上是开环产生的，需要考虑B时钟域的周期宽度。而下面这种闭环方式解决了这个问题：
![[Pasted image 20220715140134.png]]
其具体原理是：
1.  首先，asend生成一个脉冲，经过结绳、解绳到B中变为另一个脉冲
2.  该脉冲反馈回A中通过边沿采样变回A中的单周期脉冲（因为这边讨论的是慢采快，所以A总能采到B的单周期脉冲）
3.  一个简单的FSM接受反馈的脉冲并给出ready信号，表示单次采样结束，A模块可以改变adata的数据了，同时控制asend信号给出一个新的脉冲，代表单次传输结束，结绳解绳到B中后B也接受到了结束脉冲。

上面的这种方法还是不够完备，因为反馈信号也是单周期脉冲，在上面第二步中可以发现，如果A的频率比B慢，采不到脉冲岂不是僵硬，所以为了通用，慢采快还是快采慢都能适配，干脆在B中也加入A的的结绳以及FSM来控制整个流程，原理图如下：
![[Pasted image 20220715140443.png]]

![[Pasted image 20230819152834.png]]
可见，B中的状态机接收到脉冲后输出valid信号告诉外面B可以采数据了，bload置高，数据开始采样，之后b_ack置高，送入A中产生结束脉冲，结束脉冲返回B中后FSM跳回not valid状态，一次传输结束。
下面是上面的简陋版本：
![[Pasted image 20220715140608.png]]



其中标明_clk1 的信号表示该信号属于 clk1 时钟域， 同理标明_clk2 的信号表示该信号属于 clk2 时钟域。在两次src_req_clk1 之间被 src_vld_clk1“ 结绳” (pluse2toggle)，在将src_vld_clk1 用双锁存器同步以后， 将该信号转换为 dst_req_clk2(toggle2pluse)。同理，用dst_vld_clk2 将 dst_req_clk2“结绳”， **dst_vld_clk2 表明在 clk2 时钟域中， src_dat_clk1 已经可以进行正确采样了** 。 最后将 dst_vld_clk2 转换为 dst_ack_clk1(synchronizer and toggle2pluse), dst_ack_clk1 表明 src_dat_clk1 已经被 clk2 正确采样了， 此后 clk1 时钟域就可以安全地传输下一个数据了。 可以看出，“结绳法” 关键是将信号结绳以后， 使其保持了足够长的时间，以便另一个时钟可以正确地采样。

电路图如下：![[Pasted image 20220715141048.png]]
上图描述了握手协议的完整流程，其中三角带横线的符号是异或门。同时给出了两个脉冲之间结绳信号（vld信号）的产生方法。
总之：
-   **优点**：“结绳法” 可以解决快时钟域向慢时钟域过渡的问题， 且其适用的范围很广。
-   **缺点**：实现较为复杂，特别是其效率不高，在对设计性能要求较高的场合应该慎用。
#### 方法三：异步双口RAM+格雷码（异步FIFO)

处理多bit数据的跨时钟域，一般采用异步双口RAM。假设我们现在有一个信号采集平台，ADC芯片提供源同步时钟60MHz，ADC芯片输出的数据在60MHz的时钟上升沿变化，而FPGA内部需要使用100MHz的时钟来处理ADC采集到的数据（多bit）。

在这种类似的场景中，我们便可以使用异步双口RAM来做跨时钟域处理。先利用ADC芯片提供的60MHz时钟将ADC输出的数据写入异步双口RAM，然后使用100MHz的时钟从RAM中读出。

但我们读出RAM中的数据时，肯定不是一上电就直接读取，而是要等RAM中有ADC的数据之后才去读RAM。这就需要100MHz的时钟对RAM的写地址进行判断，当写地址大于某个值之后再去读取RAM。

在这个场景中，其实很多人都是使用直接用100MHz的时钟对RAM的写地址进行打两拍的方式，但RAM的写地址属于多bit，如果单纯只是打两拍，那不一定能确保写地址数据的每一个bit在100MHz的时钟域变化都是同步的，肯定有一个先后顺序。如果**在低速的环境中不一定会出错，在高速的环境下就不一定能保证了。所以更为妥当的一种处理方法就是使用格雷码转换。**

![[Pasted image 20220715142233.png]]
![[Pasted image 20220715142256.png]]

#### 方法四：二深度FIFO同步器 

![[Pasted image 20220715141311.png]]
二深度FIFO的地址实际上只有单bit,所以不需要进行gary编码，所以异步FIFO中的编码模块可以简化：![[Pasted image 20220715141327.png]]
其中的gray2bin,bin2gray都可以省略，并且空满信号的产生之间通过同或门和异或门即可产生。
限制： 由于深度只有2，所以只适合某些特定场景（突发传输要求FIFO最小深度小于2的场景）
	 
#### 方法五：DMUX同步器

对于多bit的data信号，还可以使用使能技术，也就是通过一个使能信号来判断data信号是否已经稳定，当使能信号有效的时候说明data处于稳定状态，在这种情况下终点寄存器才对信号进行采样，可以保证没有setup/hold违例。而使能信号一般使用double FF的方法来进行同步。下面是DMUX的同步示意图：
![[Pasted image 20220715141405.png]]
