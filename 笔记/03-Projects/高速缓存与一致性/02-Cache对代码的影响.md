## 问题背景

先贴出建议的代码片段1：

```c
int arr[10][128];

for (i = 0; i < 10; i++)
        for (j = 0; j < 128; j++)
                arr[i][j] = 1;
```

与之对比的代码片段2：

```c
int arr[10][128];

for (i = 0; i < 128; i++)
        for (j = 0; j < 10; j++)
                arr[j][i] = 1;
```

在有了cache的基础知识后，我们就可以简单的解答这个问题了。我们假设使用的L1 cache line大小是64字节，采用写分配及写回策略。继续假设数组`arr`内存首地址是64字节对齐。

## 问题分析

在有了以上背景假设后，我们先分析下片段1导致的cache miss/hit情况。当执行`arr[0][0] = 1`时， cache控制器发现`arr[0][0]`的值不在cache中，此时发生一次cache miss。然后从主存中读取`arr[0][0]到arr[0][15]` 的内存值到cache中。当执行访问`arr[0][1] = 1` 时会发生一次cache hit。此时内存访问速度极快。接着继续往下执行，会一直cache hit。直到执行`arr[0][16] = 1`，此时会cache miss。总结来说就是访问内存每发生一次cache miss。接下来会发生15次cache hit。因此这种初始化方法**cache命中率很高**。

我们再来分析下片段2。当执行`arr[0][0] = 1`时， cache控制器发现`arr[0][0]`的值不在cache中，此时发生一次cache miss。然后从主存中读取`arr[0][0]`到`arr[0][15]` 的内存值到cache中。当执行访问`arr[1][0] = 1` 时依然发生一次cache miss。一直执行到`arr[9][0] = 1`依然是一次cache miss。现在思考下，访问`arr[0][1]`会是怎么情况呢？ 此时就需要考虑cache的大小了。如果cache大小大于数组arr大小，cache此时相当于缓存了整个arr数组的内容。那么后续访问其他元素，确实是cache hit。似乎和片段1代码分析结果差不多。但是如果cache的大小很小，例如只有数组一半大小，那么cache命中率就很明显会降低。同样的cache大小，片段1的代码依然会获得很高的cache命中率。

## 总结

在大多数情况下，片段1代码的性能比片段2好。因此我们倾向片段1代码的写法。