![[Pasted image 20220829103448.png]]


![[Pasted image 20220829115520.png]]


会产生气泡
![[Pasted image 20220829115428.png]]



## 对握手信号的 valid+data 简单打一拍

如图3所示，是对 valid+data 打一拍后的时序图。这个时候 valid_pipe，data_pipe 和 ready 已经不再满足图2所示的时序，所以握手会失败。\
![[Pasted image 20220829224910.png]]``
```verilog
assign ready_in = ready_out;
assign fire_in = valid && ready_in;
assign fire_out = valid_pipe && ready_out
```
失败原因：

-   第一个cycle，valid+data 有效，ready也有效。这个时候 **sender 会认为数据 data1 已经被 receiver 接收**(`也就是fire_in有效` )。也就valid和data均打拍到pipe上,receiver 接收需要看pipe上的信号，对于 receiver 来说，因为 valid_pipe 是无效的，所以并没有接收数据。
-   第二个cycle，由于 sender 认为数据 data1 已经被接收，所以在这个 cycle 开始发送 data2，此时pipe上的数据仍然没有被接收，
-   第三个cycle，ready 重新变为1，receiver 看到 valid_pipe 有效，所以接收数据 data2(`fire_out有效`)。而sender 也认为 data2 被接收成功，拉低 valid 停止数据发送。

综上，receiver 在这个例子中只接收了数据 data2，握手失败。


## 握手信号 valid 打拍的改进

观察图2，我们可以看到，Receiver 端不能满足握手时序的原因是 Sender 端认为数据已经被接收，从而拉低 valid，导致 valid_pipe 也被拉低。**那么我们解决的办法应该是在 pipe 模块中保持住 valid 直到 receiver 端也握手成功,并且直到fire_out握手成功，才能进行fire_in**，如图3所示
fire_out握手成功也就是ready拉高，说明输入数据又准备开始握手，之前bug原因是输入握手成功后，不能简单的寄存这两个信号，而需要加使能，只有握手成功（`fire_in`）之后，才能寄存，然后接下来就是等输出握手成功(将valid_r拉低)，所以一开始就会输入寄存数据，等输出握手成功的那个周期，输入也可以同时握手。
![[Pasted image 20220829230029.png]]

![[Pasted image 20220829151118.png]]



## 对握手信号的ready 简单打一拍
同样的，我们来看一个例子为什么握手会失败，如图6所示：

-   第一个cycle，仅 ready 有效
-   第二个cycle，ready_pipe 有效，同时 valid 和 data 也有效，所以 sender 认为 数据 data1 已经被接收，拉低 valid。实际上 receiver 并没有接收，因为 receiver 的 ready 在这个 cycle 是无效的。

综上，receiver 在这个例子中并没有成功接收到数据，握手失败。

![[Pasted image 20220830102843.png]]


## 握手信号 ready 打拍的改进

![[Pasted image 20220830102756.png]]

一个是ready 拉高打拍有bug，一个是ready拉低打拍有bug
第一个是输出握手输入没有握手，
```verilog
assign ready_in = ready_out_r || !valid_out_r; //保证empty(直通=空闲)时候 ready_in一直是1
```
第二个是输入握手输出没有握手。-->加一个寄存器



![[Pasted image 20220830160240.png]]


full的时候不会输入输出都同时握手，因为前一周期输出要单独握手一次

valid-out 拉高
要么寄存器没数据，直接连到valid-in
要么寄存器有数据。也会拉高






  ![[Pasted image 20220830122049.png]]