### 求逆模块
bigHexP256 是 一个 **256 位 常量**
bigHexP256 = {0xFFFFFFFF，0x1，0x0，0x0，0x0，0xFFFFFFFF，0xFFFFFFFF，0xFFFFFFFF};
point_at_inifnity 是一个 三维 向量常数。
point_at_infinity.x = 0;
point_at_infinity.y = 1;
point_at_infinity.z = 0;
## 求逆原理：
1/Z 通过以下步骤计算：
U = Z;
V = 大十六进制P256;
A = 1;
C = 0;
``` c
While(U != 0) {

	while u is even do : U <-- U/2. If A is even then A <-- A/2; else A <-- (A+ bigHexP256)/2

	While v is even do : V <-- V/2. If C is even then C <-- C/2; else C <-- (C+ bigHexP256)/2

	If U >= V then : U <-- U - V, A <-- A - C; else V <-- V - U, C <-- C – A
}

Return C

```

**求逆原理介绍![[2008_-椭圆曲线加密体制的双有限域算法及其FPGA实现2.pdf]]**
 椭圆曲线加密体制的双有限域算法及其fpga实现


## 求逆模块状态机
![[Pasted image 20220531173826.png]] ^vmmxf1

SET_INIT：将第3.5章中描述的A=1 C=0   P= 大数 的值设置为内部存储器
GET_LEN：将 U 与零进行比较
SET_INF：设置 point_at_infine 到结果地址
GET_LOW：读取U或V的最低32位数据
CALC_AC：计算A/2或（A+bigHex256P）/2或C/2或（C+bigHex256P）/2
SHIFT：U 或 V 向右移 N 位，而 N 是 U 或 V 的最低 32 位数据在最右侧位置的连续零位数
CMP：比较U和V
CALC_UV：计算 U-V 或 V-U

A：开始启用
B：24 个时钟周期
C：U是零，这不是第一次比较U和零
D：U 开头为零
E：16 个时钟周期
F：U 不为零
G：2 个时钟周期，偶数
H：2 个时钟周期，奇数
I：A 或 C 计算完成
J：U 或 V 移位完成和先前的最低 32 位数据为 0
K：U 或 V 移位完成且先前的最低 32 位数据不为 0
L：U和V比较完成
M：U和V完成之间的减法






