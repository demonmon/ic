[(47条消息) 【GAOPS031】verilog 读写spi flash S25fl128L_qq_1615549892的博客-CSDN博客](https://blog.csdn.net/qq_32752869/article/details/116996482)



[【FPGA】FPGA基于spi的flash读写_EPCCcc的博客-CSDN博客_spiflash读写fpga](https://blog.csdn.net/weixin_45888898/article/details/122923523?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-122923523-blog-123146497.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-122923523-blog-123146497.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=6)


大小：8M（Byte）   （128块（Block），每块64K字节，每块16个扇区（Sector），每个扇区4K字节，每个扇区16页，每页256个字节）

![[Pasted image 20221103115136.png]]

![[Pasted image 20221119202024.png]]



## 三种状态寄存器[SR1-3]

这边插入一下关于“易失“的概念：flash存储器存储数据时具有非易失特性，即掉电数据不丢失。但是flash中也如同普通控制芯片一样，具有许多的寄存器，这些寄存器具有不同的功能，大部分的状态寄存器为非易失寄存器。

### Status Register-1
![[Pasted image 20221103113237.png]]
![[Pasted image 20221103113213.png]]

#### Busy：只读位

当 SPI FLASH 在执行 页编程， 扇区擦除，块擦除， 整片擦除， 写状态寄存器指令 等操作时, BUSY位被置1， 这些操作完成之后, **BUSY位自动清0**。当BUSY位为1时, 除了"读状态寄存器"操作和"擦除暂停"操作之外, 不接受任何其他操作。一般在程序中，用busy位是否为0，判断上一个操作[读写、擦除]是否完成。

#### WEL：只读位

【Write Enable Latch】：当执行了一个"写使能"指令后, WEL置1, 表示可以写入了。
WEL=0 : 禁止写  1：可以写入
"写禁止"时， WEL为0。“写禁止”，“页编程”， “扇区擦除”， “块擦除”，“整片擦除”， “写状态寄存器”， 执行完这些操作之后，**WEL 自动被清0， 回到禁止写入状态。**

#### BP0、BP1、BP2、 ： 非易失的、可读可写

【Block Protect bits】：他提供写保护控制和状态，即通过这三个bit，确定写保护的区域。
出厂默认这三个bit都是0，即任何区域都没有被保护。

#### TB：非易失、可读可写

【Top/Bottom Block Protect】：搭配BP0-2一起使用，确定保护的区域是从top（TB=0）开始或者从bottom（TB=1）开始计算，在写状态寄存器的时候就可以使用，但是还取决于SRP, SRL 和 WEL bits.

出厂默认为0。

#### SEC：非易失、可读可写

【Sector/Block Protect】这个bit决定了BP保护的区域是以4KB或者64KB的区域为单位。

### 状态寄存器2

![[Pasted image 20221103113922.png]]

#### QE：非易失、可读可写

【Quad Enable】：即四线使能，当这个bit被置成1时，SPI flash可以使用三种工作状态中的任意一种，**当这个bit为0时，只能使用Standard 和 Dual 模式**。

PS：有的flash这个bit在出厂的时候，这个QE bit默认为1，且不可更改。


### 三种工作模式的详细介绍

数据手册中有基本的指令. DI 输入的第一个字节就是指令代码. DI在CLK上升沿采样, **MSB** .

指令有一个或多个字节, 可能后面还有 地址, 数据, dummy。

大体格式为：`指令 + 地址/Adress + 数据/date dummy`

![[Pasted image 20221103114943.png]]
![[Pasted image 20221103115011.png]]

#### Read Data（03h）
这个指令读取数据为**Standard模式**，这个指令可以从存储器中读出一个或者多个数据，这个指令在/cs拉低后，**DI引脚在时钟的上升沿 接收8位的命令和24位的地址**，DO引脚在时钟的下降沿输出数据
![[Pasted image 20221103115448.png]]

####  Fast Read (0Bh)

快速读取数据，并不是模式的切换，此处还是**Standard模式**，只是以一个更高的时钟频率去读取数据，具体的频率支持参考数据手册中的参考表格[AC Electrical Characteristics]。除了指令部分，其他部分的时序同上。
![[Pasted image 20221103120908.png]]


#### Fast Read Dual Output (3Bh)
在输出[output]时使用==Dual模式== ，为二线输出模式，这个模式下在输出数据的时候复用两个IO，从时序图中可以看出，指令开始之前先把/CS拉低，随后DI发送8bit的指令和24bit的地址，之后空出虚空的8个clk，并在此期间，将DI的引脚模式从输入改为输出，DI复用位IO 0 ，8个虚空的clk之后两个IO一起输出数据。

![[Pasted image 20221103153444.png]]

#### Fast Read Dual I/O (BBh)
这里的I/O表示Input/Output，这里虽然还是==Dual模式== ，但是为二线输入输出模式，与上面的dual模式不同的是，原本在利用DI传输地址的时候，变成了DI 和DO 一起读取地址。在读取地址之后，要输出数据的时候，两个IO同时变成输出模式，共同输出数据。
![[Pasted image 20221103155146.png]]

**"连续读模式下"的快速读双路I/O**
快速读双路I/O指令可以通过在24位地址之后设置“**连续读模式**”位 （M7-M0）来进一步减少指令开销，
如图所示。高四位（M7-M4）通过包括或排除第一个指令代码字节控制下一给快速读双路I/O的长度。低四位（M3-M0）不需要在意（x），然而，IO引脚在第一个数据输出时钟的下降沿应优先为高阻态。
**如果“连续读模式”位（M7-M0）等于“Axh”**，则下一个读双路I/O指令（在/CS上升然后下降之后）不使用指令（BBh）代码。如图所示。这使得指令序列减少到8个时钟且允许立刻读地址在/CS拉低之后。
**如果“连续读模式”位（M7-M0）是比“AX”大的任意值**，下一个指令（在/CS拉高又拉低后）要求第一个字节指令代码，从而恢复正常模式。在执行正常指令之前“连续读模式”复位指令可以用来复位（M7-M0）。
![[Pasted image 20221103154125.png]]
快速读双路输入/输出指令系列（M7-M0=0xh或不等于Axh）

![[Pasted image 20221103155603.png]]
  
 快速读双路输入/输出指令序列代码（M7-M0=Ax） 不需要指令

#### Fast Read Quad Output (6Bh)
这里的模式是==Quad 模式== ，可以类比Dual模式下的output 与 intput/output 的读取数据模式，此处为四线输出模式。/CS拉低后，IO 0 传输8bit的指令和24bit的地址之后，IO0-3同时作为数据输出
快速读四路输出指令（6Bh）和快速读两路输出（3Bh）相似处理数据输出时四个引脚：IO0，IO1，IO2，IO3.在设备接收四路输出指令（状态寄存器位QE=1）之前，状态寄存器2的四路使能位必须执行， 快速读四路输出指令允许数据W25Q64BV发送数据以四倍标准SPI设备的速率。
dummy clocks(虚拟时钟) =  8 cycle
![[Pasted image 20221103155957.png]]

#### Fast Read Quad I/O (EBh)

这里的模式是==**Quad 模式**，为四线输入输出==，即在/CS拉低之后，除了指令，**地址和数据都是复用四线模式**。
![[Pasted image 20221103160422.png]]
 高速读四路输入/输出志林序列图表（M7-M0=0xh或不等于Axh


**连续读模式下** **快速读四路I/O**
快速读四路I/O指令可以通过在输入24位地址（A23-A0）之后设置“连续读模式”位（M7-M0）来进一步减少指令消耗，如图所示，高四位（M7-M4）通过包括或排除第一个指令代码字节来控制下一个高速I/O指令的长度。低四位（M3-M0）不需要在意（x），然而，IO引脚在第一个数据输出时钟的下降沿应优先为高阻态。

**如果“连续读模式”位（M7-M0）等于“Axh”**，则下一个读双路I/O指令（在/CS上升然后下降之后）不使用指令（BBh）代码。如图所示。这使得指令序列减少到8个时钟且允许立刻读地址在/CS拉低之后。
**如果“连续读模式”位（M7-M0）是比“AX”大的任意值**，下一个指令（在/CS拉高又拉低后）要求第一个字节指令代码，从而恢复正常模式。在执行正常指令之前“连续读模式”复位指令可以用来复位（M7-M0）。

![[Pasted image 20221103160619.png]]
 高速读四路输入/输出指令序列图表（M7-M0=Axh）

#### 八进制字节读四路I/O（E3h)

八进制字节读四路I/O（E3h）指令和快速读四路I/O（EBh）指令相似，除了低四位地址字节（A0，A1，A2，A3）必须等于0。结论就是，**四个虚拟时钟不需要了**。而且进一步减少了指令消耗，使得允许更快的代码执行的随机访问（XIP）。状态寄存器的四路使能位（QE）在读四路I/O指令的时候必须使能，为了确保更好的表现使用效率模式（HPM）指令（A3h）要提前执行一次，先于快速读四路I/O指令。
**连续读模式下的八进制字节读四路I/O**

八进制读四路I/O指令可以通过在输入24位地址（A23-A0）之后设置“连续读模式”位（M7-M0）来进一步减少指令消耗，如图所示，高四位（M7-M4）通过包括或排除第一个指令代码字节来控制下一个八进制字节读四路I/O指令的长度。低四位（M3-M0）不需要在意（x），然而，IO引脚在第一个数据输出时钟的下降沿应优先为高阻态。

如果“连续读模式”位（M7-M0）等于“Axh”，则下一个读八进制字节读四路I/O指令（在/CS上升然后下降之后）不使用指令（B3h）代码。如图所示。这使得指令序列减少到8个时钟且允许立刻读地址在/CS拉低之后。
如果“连续读模式”位（M7-M0）是比“AX”大的任意值，下一个指令（在/CS拉高又拉低后）要求第一个字节指令代码，从而恢复正常模式。在执行正常指令之前“连续读模式”复位指令可以用来复位（M7-M0）
![[Pasted image 20221103211251.png]]
 八进制字节读四路I/O指令序列（M7-M0=0xh或不是Axh）

![[Pasted image 20221103211306.png]]
八进制字节读四路I/O指令序列（M7-M0=Axh）


### 指令介绍
![[Pasted image 20221103161513.png]]

#### 写使能（06h）

　　写使能指令设置在状态寄存器（S1）的写使能锁定位（WEl）为1。WEL位必须在每一次页编写，扇区擦除，区块擦除，片擦除和写状态寄存器之前优先设置。写使能指令在每次/CS位低的时候进入，在CLK的上升沿将指令代码“06h”通过DI移位发送到设备，然后/CS拉高。
![[Pasted image 20221103204610.png]]

**写禁止（04h）**

　　写禁止指令将状态寄存器中的写使能锁定位复位为0。写禁止指令在/CS位低的时候写入，通过DI引脚移位发送指令代码“04h”到设备，然后/CS拉高。注意，WEL位在上电，写状态寄存器，页编程，扇区擦除，区块擦除和片擦除指令完成之后自动复位。

![](https://img2018.cnblogs.com/i-beta/1919866/202002/1919866-20200219112125521-1388572091.png)

**读状态寄存器1（05h）和读状态寄存器2（35h）**

读状态寄存器指令允许8位状态寄存器被读。该指令在/CS拉低后在CLK的上升沿通过DI引脚移位指令代码“05h”到状态寄存器1和“35h”到状态寄存器2。在CLK的下降沿通过DO（MSB在前）将状态寄存器位移出。

状态寄存器位包括BUSY，WEL，BP2-BP0，TB，SEC，SRP0，SRP1,和QE位。

读状态寄存器指令可以在任何时间使用，甚至在编程，擦除或写状态寄存器的时候。这要求监视BUSY位来决定当整个周期完成后是否要接收其他指令。状态寄存器可以连续读，如图所示，该指令通过将/CS引脚拉高来完成。

![[Pasted image 20221103204810.png]]


**写状态寄存器（01h）**

　写状态寄存器指令允许状态寄存器被写。一个写使能指令在设备收到写状态寄存器指令之前发送（状态寄存器WEL位等于1）。一旦写使能，该指令会在/CS拉低时，发送指令代码“01h”之后写状态寄存器数据字节如下图所示。
　只有非易失性状态寄存器位SRP0，SEC，TB，BP2，BP1，BP0（状态寄存器1的S7，S5，S4，S3，S2）和QE，SRP1（状态寄存器2的S9，S8）可以被写。所有其他状态寄存器位位只读且不可以通过写状态寄存器指令。


![[Pasted image 20221103210953.png]]

**页编程（02h）**

页编程指令允许在之前擦写（FFh）存储器的位置编程从一个字节到256字节（一页）数据。一个写使能指令必须在设备接收到页编程之前执行（状态寄存器位WEL=1）。通过将/CS引脚压低，然后将指令码“02h”跟着一个24位地址(A23-A0)移动和至少一个数据字节，进入DI引脚。当数据发送到设备是/CS引脚必须保持低电平在整个长度的指令时间内。

如果整个256字节通过页编程写，最后的地址字节（最后的8位地址位）应该被置零。**如果最后的地址字节不为零，且时钟的长度大于剩下的页的长度。若超过256个字节被发送到设备，地址将会回滚到地址的最开始且覆盖原来发送的内容。**

**四输入页编程（32h）**

在前面擦除（FFh）指定位置使用四个引脚：IO0，IO1，IO2，IO3，四路页编程指令允许最大256自己的的数据被编程。四路页编程可以改善时钟速度小于5MhzPROM编程器和应用程序的的表现。拥有更快的时钟速度的系统不是很适合于四路页编程指令（状态寄存器1，WEL=1）原因是应为固有页面编程时间大于数据保持的时间。

为了使用四路页编程，状态寄存器2的四路使能位必须置一（QE=1）。在设备接收四路页编程指令之前写使能指令必须被执行（状态寄存器1，WEL=1）。这个指令开始于/CS处于低电平时，然后在24位地址（A24-A0）之后移位发送指令代码“32h”且至少一个数据字节，在IO引脚上。/CS引脚在整个指令长度期间且数据发送期间必须保持低电平。所有其他四路页编程的功能和标准页编程完全相同。四路页写指令时序如图所示。

![[Pasted image 20221103211822.png]]
四路输入页编程指令时序图表

#### 扇区擦除（20h）

扇区擦除指令时在指定的扇区（4KB）之内设置**所有的存储器擦除为FFh**。一个写使能指令在设备收到扇区擦除指令之前必须被执行（状态寄存器位WEL必须等于1）。指令开始于/CS拉低的时候，且紧跟在24位地址后面移位发送指令代码“20h”。扇区擦除指令时序如图所示。
![[Pasted image 20221103212340.png]]

**32KB区块擦除（52h）**

　　区块擦除指令在指定的区块内（32KB）设置所有存储区为1，（FFh）。在设备接收区块擦除指令之前必须先发送写使能指令（状态寄存器位WEL=1）。该指令在/CS引脚处于低电平时开始，且跟在24位区块地址（A23-A0）之后移位发送指令代码“52h”。区块擦除指令序列如图所示。

![[Pasted image 20221103212527.png]]




#### 64KB区块擦除（D8h）

区块擦除指令在指定的区块内（64KB）设置所有存储区为1，（FFh）。在设备接收区块擦除指令之前必须先发送写使能指令（状态寄存器位WEL=1）。该指令在/CS引脚处于低电平时开始，且跟在24位区块地址（A23-A0）之后移位发送指令代码“D8h”。区块擦除指令序列如图所示。

![[Pasted image 20221103212617.png]]

#### 20片擦除（C7h/C6h）

片擦除指令在指定的区块内（64KB）设置所有存储区为1，（FFh）。在设备接收区块擦除指令之前必须先发送写使能指令（状态寄存器位WEL=1）。该指令在/CS引脚处于低电平时开始，且跟在24位区块地址（A23-A0）之后移位发送指令代码“C6h或C7h”。片擦除指令序列如图所示。
![[Pasted image 20221103212808.png]]


#### 擦除暂停（75h）**

擦除暂停指令“75h”，允许系统中断一个扇区擦除或区块擦除工作且之后从从其他扇区或区块读数据或写数据。擦写暂停指令时序如图所示。

在擦除暂停期间不允许写状态寄存器指令（01h）和擦除指令（20h，52h，D8h，C7h，C6h）。擦除暂停在扇区或区块擦除期间是有效的。如果在片擦除或编程工作，擦除暂停指令被忽略。

![[Pasted image 20221103213034.png]]

#### 擦除释放（7Ah）

　擦除释放指令“7Ah”在擦除暂停之后发送给设备来释放扇区或区块操作。擦除释放指令“7Ah”只有当状态寄存器中的SUS位等于1且BUSY位等于0时会被设备接收。执行完之后SUS位会被立即清零，BUSY位会在200ns内从零拉高为1且扇区或区块完成擦除操作。如果SUS位等于0或BUSY位等于1，该指令“7Ah”会被设备忽视。擦除释放指令时序如图所示。
![[Pasted image 20221103213131.png]]
 擦除释放指令时序





