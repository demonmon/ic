---
title: 第四周
updated: 2022-04-06
created: 2022-04-06
---
## 概述

-   测试平台（testbench）是整个验证系统的总称。
-   测试平台包括验证结构中的**各个组件**（层次）、**组件之间的连接关系**（通信）、**测试平台的配置和控制**。
-   从更系统的意义来讲，它还包括编译仿真的流程、结果分析报告和覆盖率检查等。
-   从狭义上讲，我们主要关注验证平台的结构和组件部分，他们可以产生设计所需要的各种输入，也会在此基础上进行设计功能的检查。
- 
## 测试环境结构图
测试平台（testbench），测试平台的配置与控制，软件与硬件差别很大
整学期核心--**覆盖率**
![image1](image1-9.png)
- compile：1.RTL文件编译 2.tb文件编译
- monitor怎么拿到dut的输入，可以例化一个interface， 从interface里面监测数据。
- 所有tb组件和dut连接都是用接口。
- Monitor 与 checker怎么样做通信的？
- Clock/reset ：验证组件也需要时钟和复位信号？ 因为数据需要一拍一拍打进去，所以需要时钟，monitor也需要时钟和复位信号来采集数据。
![image2](image2-7.png)
1.模块代码功能都是独立的，独立和放在一块谁好谁坏？
2.Interface 连接
3.验证组件需要进行通信（mailbox 信箱）
4.checker需不需要时钟和复位信号

## 验证环境组件
**三大验证组件**
### 激励发生器
-   Stimulator（激励发生器）是验证环境的重要部件，在一些场合中，它也被称为driver（驱动器）、BFM（bus function model，总线功能模型），behavioral（行为模型）或者generator（发生器）。
-   Stimulator的主要职责是**模拟与DUT相邻设计的接口协议**，只需要关注于如何模拟接口信号，使其能够以真实的接口协议来发送激励给DUT。
-   Stimulator**不应该违反协议，但不拘束于真实的硬件行为**，还可以给出更多丰富的只要协议允许的激励场景。
-   **比真实硬件行为更丰富的激励**，会使得在模块级的验证更加充分，因为它不但验证过了硬件普通的接口协议情景，还模拟出更多复杂的、在更高系统级别无法产生出来的场景。
-   Stimulator的接口**主要是向DUT之间连接**，此外，也应该有时钟和复位的输入，确保生成的数据同DUT的接口一侧是同步的关较精细的stimulator还可以有其它的配置接口用来控制接口的数据生成。
-   Stimulator也**可以有存储接口数据生成历史的功能**，这可以用来在仿真运行时或者结束后查看接口数据，方便统计或者调试。
-   从stimulator同DUT的连接关系来看，我们可以将其进一步分为两种：**initiator（发起器）和responder（响应器）**。
-   就我们要验证的MCDF来看，与**下行通道从端（channel slave）的连接或寄存器接口的连接**，这两部分的stimulator都属于initiator，它们的功能是主动发起接口数据传输。
-   与MCDF formatter接口的连接，该stimulator则属于responder，它的职责是对接口的数据发送请求做出响应，而它本身不会主动发送数据。
![image3](image3-6.png)

### 监测器
-   Monitor（监测器）的主要功能是**用来观察DUT的边界或者内部信号**，并且经过打包整理传送给其它验证平台的组件，例如checker（比较器）。
-   从监测信号的层次来划分monitor的功能，它们可以分为观察**DUT边界信号**和观察**DUT内部信号**。
    -   **观察DUT边界信号**。对于系统信号如时钟，可以监测其频率变化；对于总线信号，可以监测总线的传输类型和数据丙容，以及检查总线时序是否符合协议。
    -   **观察DUT内部信号**。从灰盒验证的手段来看，往往需要探视DUT内部信号，用来指导stimulator的激励发送，或者完成覆盖率收集，又或者完成内部功能的检查。
-   如果没有特殊的需要，我们应采取**灰盒验证**的策略（而非白盒）。观察的内部信号应当尽量**少**，且应当是**表示状态的信号**。不建议采集中间变量信号的原因在于，这些信号的时序、逻辑甚至留存性都不稳定，这种不稳定对于验证环境的收敛是有害的。
-   可以**通过接口信息计算的**，就**尽量少去监测内部信号**，因为这种方式也有悖于假定设计有缺陷的验证思想。我们观测到的内部信号在被环境采纳之前也有必要确认它们的逻辑正确性，这一要求可以通过动态检查或者断言触发的方式来实现。
### 比较器

-   checker肩负了**模拟设计行为**（reference model）和**功能检查**的任务将DUT输入接口侧的数据汇聚给**内置的reference model（参考模型）**，reference model在这里扮演了模拟硬件功能的角色通过**数据比较**的方法，检查实际收集到的DUT输出端接口数据是否同reference model产生的期望数据一致
    -   **线上比较**（online check）：在仿真时收集数据和在线比较，并且实时报告
    -   **线下比较**（offline check）：将仿真时收集到的数据记录在文件中，在仿真结束后，通过脚本或者其他手段进行数据比较
-   reference model也会**内置一些缓存**，分别存放从DUT输入端观察到的数据，以及经过功能转换的数据，同时Checker也有其**它缓存来存放从输出端采集到的数据**。

## 任务和函数
**区别**
-   fuction**不会消耗**仿真**时间**，而task则**可能会消耗**仿真**时间**
-   **function无法调用task**（因为task可能会消耗仿真时间），而task可以调用function
-   一个可以返回数据的function**只能返回一个单一数值**，而任务或者void function不会返回数值
-   一个可以返回数据的function可以**作为一个表达式中的操作数（赋值）**，而该操作数的值即function的

### 函数function
-   **必须**提供返回值
-   void函数不会返回具体数值，但是**返回空**
-   函数的**参数列表方向**也可以声明为**input、output、inout和ref**
-   对于函数返回的方式，也同C一致，有两种方法，既可以**使用return直接返回值**，也可以将值**赋给与函数同名的变量**
-   只是**return会立即返回**，而赋值给函数同名变量后将**继续执行**后续代码
-   如果调⽤具有返回值的函数，但是⼜不适⽤该返回值时，我们建议为其添加
-   **void’(some_fuction())**进⾏强制转换，不要返回值**

```systemverilog
function [15:0] myfuncl(input [7:0] x,y); 
  myfuncl = x*y-1; 
endfunction 

function [15:0] myfunc2(input [7:0]x,y); 
  return x*y-1; 
endfunction

function [15:0] myfunc3(input [7:0]x
                      ,input [7:0]y); 
  myfunc3 = x*y-1; 
endfunction 

function void myfunc4(input [7:0] x,
                      input [7:0] y,
                      output [15:0] z ); 
  z = x*y-1; 
endfunction //没有返回值

initial begin 
  byte unsigned a=3;
  byte unsigned b=4; 
  byte unsigned c1,c2; 
  myfunc4(a,b,c1);
  $display("c1=%0d",c1); 
  c2=myfunc3(a,b);
  $display("c2=%0d",c2); 
end
```

**首要目的提供返回值，类似于task，函数参数列表可以声明input output inout和 ref，未标明默认input。默认logic类型**
两种声明方式:
![image10](image10-2.png)


### 任务task
-   任务的定义**可以指定参数**，**input、output、inout及ref** 皆可（使用ref时**实参形参类型必须高度一致**）
-   任务**可以消耗**仿真时间
-   任务**可以调用其他任务或者函数**
-   return能**提前结束**任务（类似于break用法，直接退出后面**不执行**）
-  任务没有返回值，output不叫返回值，叫输出类型的参数
```systemverilog
`timecale 1ns/1ps
task mytask3(input [7:0] x,
             input [7:0] y,
             output [15:0] z); //输出类型使用ref，可以实时传参，不需要task执行完毕
  #5ns; 
  z = x*y-1; 
  return;        //强制退出，后面的不执行
  #5ns; 
endtask 


  byte unsigned a = 3; 
  byte unsigned b = 4; 
  logic [15:0] c1, c2; 

initial begin
	mytask3(a,b,c1);
	$display("c1=%0d", c1); 
end 

initial begin 
  repeat(12) begin
  #1ns; 
  $display("etime stc1=80d", $time, cl); 
end

```
### 参数默认值
-   SV允许方法声明参数的默认值（**默认input**），参数的方向可以时input、inout、output和ref
-   带有参数默认值的方法被调用时，如果这些参数没有被传递值，那么编译器将会为这些参数**传入对应的默认值**
-   SV允许类似于模块例化一样，可由参数**位置顺序**在调用方法时传递参数，也可以由参数名字调用方式时绑定参数
-   参数未声明类型默认**1-bit的logic**类型
```systemverilog
task read(int j=0,int k,int data=1); // j默认值为0 data默认值为1
  ...
endtask 

read(n,5);   // is equivalent to read(0,5,1); 
read(2,5);   // is ecquivalent to read(2,5,1); 
read(,5,);   // is equivalent to read(0,5,1); 
read(,5,7);  // is ecquivalent to read(0,5,7);
read(1,5,2); // is equivalent to read(1,5,2); 
read();      // error;k has no default value 
read(1,,7);  // error;k has no default value
```

### fuction和task的参数方向
-   input采样只在函数或者任务的**入口**，其他时候不影响内部或者外部的数值。
-   output驱动只在函数或者任务的**出口**，其他时候不影响内部或者外部的数值。
-   ref为引用本质上为一个值，可以**实时传递，既检测也修改。**
-   const ref可以时刻检测外部数据，但是不对其进行修改。
#### system verilog中的参数传递
先说明，sv 中的静态数组、动态数组、队列都是用一块内存存放，而他们的名字作为该内存的地址，这点应该和 c 一致，但 sv 里面没有指针的概念。
传递这种大片内存的值一般只有两种规则
-   地址传递，函数内部修改可以改变函数调用的值。
-   值传递，将整片空间复制一份，函数内部修改不会改变函数调用的值。
但是 system verilog 里面**关键字有三个，input、output、ref**具体哪个对应哪个，我们来试一下。以静态数组作为模板来试。
```systemverilog
function void run();
   int r[2];
    r[0] = 1;
    r[1] = 2;
    f(r);
    $display("%0x %0x",r[0],r[1]);
endfunction

```
##### 加 input 的情况
```systemverilog
function void f(input int a[2]);
    a[0] = 3;
endfunction
```
![[Pasted image 20220616110738.png]]
1.  函数调用之前，内存里只有 r 数组的空间 r={2,1}
2.  函数调用之后，会将 r 拷贝一份到 a，函数里面用的都是 a 这份空间,
3.  函数调用之后，赋值后，修改的是 a 这份空间的值
4.  函数返回之后，**a 空间会被释放掉**，所以 r 的值并没有修改
对于input来说，实际参数（r）会将其数据拷贝一份到形式参数，以至于函数调用改变的的值都是**形式参数的值**,最后会释放掉。
**因此，input 是标准的值传递。**

##### 加 output 的情况

```systemverilog
function void f(output  int a[2]);
    a[0] = 3;
endfunction
```
![[Pasted image 20220616111126.png]]
1.  函数调用之前，内存里只有 r 数组的空间
2.  函数调用之后，会新建一份 a 数组，**注意这里并不会把 r 的值传进来，函数里面用的都是 a 这份空间**
3.  函数调用之后，赋值后，修改的是 a 这份空间的值
4.  函数返回之后，会将 r 指向 a 空间，而原来 r 指向的空间会被释放掉，所以 r 的值都被修改了

**这里不会把实参的数据拷贝给形参，待形参的值修改之后，则实参r指向形参a的空间，这里释放的是实参r空间。**

**因此，加 output，采用的是地址传递，确切的说是反向的地址传递，数组共有两份，函数内部看到的是新建的一份，并传递给函数调用处，因此，函数调用前看到的是第一份，函数调用后看到的是新建的那份。**

##### 加 ref 的情况
```systemverilog
function void f(ref int a[2]);
  a[0] = 3;
endfunction

```

![[Pasted image 20220616111709.png]]

1.  函数调用之前，内存里只有 r 数组的空间
2.  函数调用之后，会将 a 指向 r 所在的空间，函数里面用的都是这份空间
3.  函数调用之后，赋值后，修改的是这份空间的值，所以 r 和 a 都修改了
4.  函数返回之后，所以 r 的值只有部分修改

因此，**加 ref，采用的是标准的地址传递，只有一份数组，函数内部和调用处都是访问该空间。**

***对比来看，input 是将函数外面的值传递到函数里面，调用结束之后，函数里面的值就被丢弃了；out 是将函数里面的值传递到函数外面来，调用结束之后，函数外面的值就丢了；ref 是函数内部和外部看到的是同一份值，哪里改都会改。  
另外，可以看出，采用 ref 关键字是占用内存最小的，因为只有一份数组，这样能提高效率。  

**动态数组或队列作为参数**  
如果传递的是动态数组或者队列，其结果是一模一样的，不另外作说明。
**类作为参数**  
但是！！如果传递的是类，则会有点不一样。
```systemverilog
class c;
 int v0;
  int v1;
endclass
function void run();
    c c0;
    c0 = new();
  c0.v0 = 1;
   c0.v1 = 2;
   f(c0);
   $display("%0x %0x",c0.v0,c0.v1);
endfunction
function void f(input/output/ref c c0);
 c0.v0 = 3;
endfunction

```

结果是：

1.  input：`3 2`
2.  output：报 null point 错误
3.  ref：`3 2`

可以看出，如果是传递类的话，使用 input 和 ref 是一样的，都是地址传递，而 output 和数组的结果是一样的。


## 静态函数和动态函数

-   如果变量被声明为automatic，那么进入该方法后，就会自动创建，离开该方法后，就会被销毁；
-   而static则是在仿真开始时就会被创建，直到仿真结束，可以被多个方法/进程共享。
通过几个例子看其区别：
```systemverilog
function automatic int auto_cnt(input a);     //定义为automatic后，cnt默认为automatic
    int cnt = 0;
    cnt += a;
    return cnt;
  endfunction
$display("@1 auto_cnt = %0d", auto_cnt(1));     //@1 auto_cnt = 1
$display("@2 auto_cnt = %0d", auto_cnt(1));     //@1 auto_cnt = 1

function automatic int auto_static_cnt(input a); //虽然方法定义为automatic，但是因为cnt定义为static
    static int cnt = 0;
    cnt += a;
    return cnt;
  endfunction
$display("@1 auto_static_cnt = %0d", auto_static_cnt(1));//auto_static_cnt = 1
$display("@2 auto_static_cnt = %0d", auto_static_cnt(1));//auto_static_cnt = 2

function static int static_cnt(input a);      //虽然static的function隐含其中的变量就是static，因为我们对cnt进行了初始化，所以必须明确指出其是static还是automatic。
    automatic int cnt = 0;
    cnt += a;
    return cnt;
  endfunction
$display("@1 static_cnt = %0d", static_cnt(1));  //@1 static_cnt = 1
$display("@2 static_cnt = %0d", static_cnt(1));  //@1 static_cnt = 1
//即使方法是static的，但是如果我们把变量定义为automatic，每次结束方法就会销毁该变量
//任何隐含为static的方法，如果我们需要对其中的变量进行初始化，一定要指定其是static还是automatic的，否则会报error

int cnt = 0;
function automatic int auto_cnt(input a);     //如果是外部定义的，在automatic的方法中外部变量默认还是static的，不受此影响
    cnt += a;
    return cnt;
  endfunction
     auto_cnt(1);
$display("@1 auto_cnt = %0d",cnt );    //auto_cnt = 1
    auto_cnt(1);
$display("@2 auto_cnt = %0d", cnt);    //auto_cnt = 2

```










stimulator按和DUT连接关系可分为：1.initiator（发起器） 2.responder （响应器）
**2.monitor**
主要功能：观察DUT**边界**或者**内部**信号，并且经过打包整理传送给其他验证平台组件（不一定是checker）
**观测DUT边界信号**：例如系统信号时钟，可以监测频率变化。可以做协议检查，对于总线信号，可以监测总线的传输类型和数据内容，以及总线时序是否符合协议。
**监测DUT内部信号**：往往需要探视DUT内部信号，用来指导stimulator的激励发送，
以黑盒边界信号为主 观测内部信号为辅。例如想要收集一个信号的跳转，也可以观测内部信号
![image5](image5-4.png)
monitor不能从stimulator获取激励数据，而是从interface获取数据，因为这样更可靠，监测接口最准确。可能会发错数据
输入有输入的monitor 输出有输出的monitor 功能要单一 要分开

**Checker 比较器**

![image6](image6-3.png)

**模拟设计行为和功能检查的任务**
Reference model 不太关心时序 主要关心功能。越复杂越需要自己写。不能写RTL，例如傅里叶变换，RTL和数学模型不一样，参考模型可以拿c函数来做。这个模型怎么做，不该参考真实硬件模型（RTL代码），因为RTL设计本来就不可靠。从功能描述来看谁对的。
![image7](image7-3.png)

![image8](image8-2.png)

任务与函数
![image9](image9-2.png)

函数function
首要目的提供返回值，类似于task，函数参数列表可以声明input output inout和 ref，未标明默认input。默认logic类型
两种声明方式
![image10](image10-2.png)

任务task
![image11](image11-2.png)

任务名称（mytask1等）不能当作返回量，task还可以加延时语句
![image12](image12-2.png)
将返回值转为空类型
注意要给数据类型 不然默认为1位宽的数据
![image13](image13-2.png)
任务没有返回值，output不叫返回值，叫输出类型的参数
