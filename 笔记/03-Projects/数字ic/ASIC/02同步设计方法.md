#同步电路

## 同步设计
优点：
- 易于实现
- 一定程度降低噪声带来的影响
- 可以使用对STA方法对关键路径进行分析，
- 形成流水线问题
缺点：
- 工艺愈发先进，路径延时已经超过门延时
- 时钟抖动 偏移造成影响无法忽略
- 时钟带来功耗越来越显著

### 复位
复位方式：1。异步复位 2.同步复位

![[Pasted image 20220704225030.png]]



#### 同步电路
**同步复位的优点**：信号间是同步的，能滤除复位信号中的毛刺，有利于时序分析。
**同步复位的缺点**：大多数触发器单元是没有同步复位端的，采用同步复位会多消耗部分逻辑资源。且复位信号的宽度必须大于一个时钟周期，否则可能会漏掉复位信号。
![[Pasted image 20220704225447.png]]

#### 异步电路
![[Pasted image 20220704225427.png]]
异步复位的优点：
- 大多数触发器单元有异步复位端，**不会占用额外的逻辑资源**。
- 且异步复位信号不经过处理直接引用，设计相对简单，信号识别快速方便。
- 不依赖于时钟
**异步复位的缺点：**
- 复位信号与时钟信号无确定的时序关系，异步复位很容易引起时序上 removal 和 recovery 的不满足。
- 复位信号容易受到外界的干扰，如毛刺等影响，产生意外的复位操作；
- 复位信号释放的随机性，可能导致时序违规，倘若复位释放时恰恰在时钟有效沿附近，就很容易使电路处于亚稳态，如下图
![[Pasted image 20220704230058.png]]

**Recovery timing check**
Recovery time是指在时钟有效沿到来之前，复位信号保持高电平的最短时间。即复位信号变到非复位状态的电平必须在clk之前一定的时间到达。满足这个Recovery time，可以确保在时钟有效沿来临时，异步复位信号处于无效状态，从而确保正常的数据采样。

**Removal timing check**
Removal time是指在时钟有效沿来临之后，异步复位信号需要继续保持有效的最短时间。满足这个最短时间才能确保对寄存器进行正常的复位。Removal time check的波形图如下图所示。Removal timing check与hold time check类似

从Removal 和Recovery time的定义知道，只要DFF的复位信号不在时钟有效沿附近变化（复位信号远离时钟有效沿），就可以保证电路的正常复位和撤销。

同步复位虽然解决了当时钟的有效沿来临的时候rst_n的边沿也正好来临所出现的冒险与竞争。但是从综合的电路上可以看出，多了一个组合逻辑MUX。
如果设计中所有的复位都是这样的，那会增加很多的资源，导致芯片面积很大。那么有没有更好的解决办法呢？答案是有，那就是**异步复位同步释放电路。**


#### 异步复位同步释放



![[Pasted image 20220704230515.png]]


![[Pasted image 20220913200535.png]]


rst_i=rst_i_d1=rst_i_d2

-   当异步复位（rst_i）无效，即为高电平时，同步后的复位信号 rst_o 也为高电平；
-   当异步复位有效时，同步后的复位信号立刻为低电平（ 0），即实现了“异步复位”；
-   信号释放时，会在时钟上升沿来临时，才可以恢复为 高电平（1），实现“同步释放”；
![[Pasted image 20220913202157.png]]

Ps:给出一道例题：
(22届紫光秋招)假定时钟毛刺，异步复位可以不管时钟，只要复位满足就对电路复位。判断是否正确？如果不正确请给出理由？

不正确。影响异步复位信号能否安全复位的因素除了时钟产生的毛刺，另外一点很重要的原因就是：当异步复位信号在释放时，如果刚好发生在时钟有效边沿的附近，那么有可能会产生亚稳态，而导致电路复位失败。

### 跨时钟域

#### 单bit
延迟打拍法
一般设计中使用两级触发器进行缓存即可满足设计时序需求。大量实验表明，三级触发器缓存可解决 99% 以上的此类异步时序问题。


![[Pasted image 20220704232854.png]]
两级触发器延迟打拍并检测信号上升沿的 Verilog 描述如下：
```verilog
module delay_clap(  
    input       clk1,  //异步慢时钟  
    input       sig1,  //异步信号  
  
    input       rstn,  //复位信号  
    input       clk2,  //目的快时钟域市政  
    output      sig2); //快时钟域同步后的信号  
  
   reg [2:0]    sig2_r ;   //3级缓存，前两级用于同步，后两节用于边沿检测  
   always @(posedge clk2 or negedge rstn) begin  
     if (!rstn) sig2_r  <= 3'b0 ;  
     else       sig2_r  <= {sig2_r[1:0], sig1} ;  //缓存  
   end  
   assign sig2 = sig2_r[1] && !sig2_r[2] ; //上升沿检测,只有在 01x时候为高，并且这种属于一定只拉高一个周期 下周期一移位则必然是低
```



![[Pasted image 20220704232403.png]]



![[Pasted image 20220704232415.png]]
上图跨时钟域之后，第一个clock产生亚稳态，使得稳定之后仍然不是adat的1，再到第二个clock时候 此时并不会产生亚稳态，因为建立时间，保持时间都满足。第三个clock在bq2上输出，此类方法俗称延迟打拍法。只适用于单bit跨时钟域


### 时钟切换电路
#### 相关源时钟切换

[FPGA/数字IC秋招笔试面试031——Glitch free 无毛刺时钟切换电路、时钟无缝切换、时钟无毛刺切换技术【2022届】 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/367368591)

![[Pasted image 20220913203709.png]]


![[Pasted image 20220705191311.png]]



**在时钟的下降沿处寄存选择控制信号，保证了控制信号不会在 2 个时钟源的高电平处进行跳变，这样就防止对输出时钟进行截断（截断导致毛刺）**。
![[Pasted image 20220705191327.png]]

**那么为什么要使用下降沿触发的DFF呢？**
原因是这样，所谓去除毛刺，就是要避免毛刺的产生，那么得先明白毛刺是如何产生的，其实只要两个时钟相反时切换都换产生毛刺，如果没有DFF，比如，在clk1为低电平时，sel马上切换到clk0，恰巧clk0为高电平，但高电平只剩一点了，所以便产生了一个高电平毛刺，当然同理也有低电平毛刺。
但在此时钟切换电路中，sel信号的传输存在着DFF的延迟，也就是说在时钟切换时，两个DFF的输出存在都是0的情况，此时clk_out输出为低电平，这段时间可能很短，**如果在两个时钟都是高电平的时候切换，可能会产生低电平毛刺**，所以考虑要在两个都为低电平的时候切换最为稳妥。

那么使用下降沿触发的DFF，尽管sel已经有切换指令了，但需要等到下降沿后才通过DFF传到后面，因为是下降沿，所以高电平已经结束了，切换过去可确保无毛刺。
![[Pasted image 20220705192137.png]]




一个时钟的选择反馈到了另一个时钟（两个 QN，即~Q），这种反馈机制使得门控开关在选择输出下一个时钟之前，**必须先取消当前时钟的输出选择**，这样避免了任何可能出现的毛刺 Glitch。
![[Pasted image 20220705191436.png]]
上图即使产生亚稳态，但他输出是它与源时钟相与，下降沿之后源时钟一定是0所以相与之后也是0，并不会影响

在这个电路中有 3 条时序路径需要特别考虑：
（1）SELECT 控制信号到任意一个下降沿有效的触发器 ；
（2）DFF0 的输出到 DFF1 的输入；
（3）DFF1 的输出到 DFF0 的输入

如果这三条路径中的任一路径上的信号在目的寄存器时钟的捕获沿时发生变化，则寄存器的输出有一定的机会会进入**亚稳态（meta-stable）**，这意味着会进入理想的 0 和 1 之间的一个状态。(在此例中，捕获沿均为下降沿)。

在芯片的启动时，DFF0 和 DFF1 两个寄存器都应该复位为“0”状态，这样在最开始时，两个时钟都没有被选中输出。通过在“0”状态下起点两个触发器，时钟开关内置了**容错功能**。
 假定在启动时有个错误导致其中一个时钟没有进行翻转。如果使用这个错误时钟的触发器的初始状态是“1”状态，而此时这个触发器由于没有时钟的翻转边沿触发，所以导致该寄存器的输出状态不变，这就阻止了对另一个时钟的选择。通过让两个寄存器都以“0”状态开始，那么即使有一个时钟没能正常的工作，另一个正常的时钟也能通过门控输出。

#### 无关时钟源切换

![[Pasted image 20220704233900.png]]

上面组合逻辑会产生毛刺


![[Pasted image 20220704234157.png]]





时钟无毛刺电路 ，都是在时钟下降沿时候切换电路，都是下降沿同步之后就不会产生毛刺。
### 什么是FIFO

FIFO全称 `First In First Out`，即先进先出。

FIFO主要用于以下几个方面：
-   跨时钟域数据传输
-   将数据发送到芯片外之前进行缓冲，如发送到DRAM或SRAM 
-   存储数据以备后用 

FIFO是异步数据传输时常用的存储器，多bit数据异步传输时，无论是从快时钟域到慢时钟域，还是从慢时钟域到快时钟域，都可以使用FIFO处理。

### 2 重要参数
FIFO中重要的参数有`深度、宽度、空标志、满标志、读时钟、读时针、写时钟和写时针`
### 同步FIFO
同步FIFO就是一个缓存器（双口RAM），其中最关键的部分就是·如何判断为满和为空
![[Pasted image 20220705152653.png]]
#### 如何判断full empty

##### 计数器

```verilog
```verilog
always @ (posedge clk or negedge rstn) begin
        if(!rstn)
            cnt <= 0;
        else if (wr_en && !rd_en && !fifo_full) //有效的只写入
            cnt <= cnt + 1;
        else if (!wr_en && rd_en && !fifo_empty) //有效的只读取
            cnt <= cnt - 1;
        else 
            cnt <= cnt;
    end

    //空满判断
    assign fifo_full = (cnt == depth)? 1 : 0;
    assign fifo_empty = (cnt == 0) ? 1 : 0;
```
```

##### addr拓展一位标志位
```verilog
 assign empty=(wr_adr_ptr==rd_adr_ptr)?1'b1:1'b0;
 assign full = ({(!wr_adr_ptr[date_addr]), wr_adr_ptr[date_addr-1:0]}==rd_adr_ptr)?1'b1:1'b0;
```

![[Pasted image 20220705152737.png]]





