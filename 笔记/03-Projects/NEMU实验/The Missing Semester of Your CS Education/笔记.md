# The Missing Semester of Your CS Education


![[Pasted image 20221010202219.png]]
 
   
   这个>>是追加，>是覆盖写
pipe 取左侧输出成为右侧输入
tail---
![[Pasted image 20221010202544.png]]


![[Pasted image 20221010204550.png]]

## 重定向

文件描述符	代表的含义	默认情况	对应文件句柄位置
| 文件描述符 | 代表的含义 | 默认情况 | 对应文件句柄位置 |
| ---------- | ---------- | -------- | ---------------- |
| 1          |   标准正确输出（standard output）       |    输出到屏幕      |      /proc/self/fd/1            |
| 2          |      标准错误输出（error output）      |    输出到屏幕（即控制台）|         /proc/self/fd/2         |
| 0           |    标准输入（standard input）        |     从键盘获得输入     |          /proc/self/fd/0        |

| 输出重定向         | 代表含义 |
| ------------------ | -------- |
| command > filename |      把**标准正确输出**重定向到指定文件中    |
| command 1 > filename |       同上   |
| command >> filename |      把标准正确输出**追加**到指定文件中    |
| command 1 >> filename |      同上    |
| command 2 > filename |       把**标准错误输出**重定向到指定文件中   |
| command 2 >> filename   |    同上      |

- “>” 或者 “>>” 符号表示对标准输出（包括正确的和错误的输出）进行重定向。
这两个符号的左边表示**文件描述符**，**如果没有的话表示1，也就是标准正确输出**，符号的右边可以是一个文件，也可以是一个输出设备。
- 当使用">" 符号时，会判断右边的文件存不存在，**如果存在的话就先删除，然后创建一个新的文件，不存在的话则直接创建**。
- 当使用 “>>” 符号进行追加时，则不会删除原来已经存在的文件。当使用 “>>” 符号进行追加时，则不会删除原来已经存在的文件。
cmd
![[Pasted image 20221013151913.png]]
在我们执行 ls /home/test/a.txt /home/test/b.txt 命令后，一共有两种输出

将标准正确输出重定向到log文件,错误依旧打印出来
![[Pasted image 20221013152025.png]]

进一步把错误也定位到另一个log文件
![[Pasted image 20221013152248.png]]
![[Pasted image 20221013152259.png]]

输入重定向 
此时我们觉得自己在键盘上敲比较累，还是直接让**cat读取一个文件吧**。那么我们需要利用输入重定向：
![[Pasted image 20221013153215.png]]
神奇的事情发生了，/home/test/record-new.log 文件里面的内容被替换成了/home/test/record-show.log 文件里的内容。那麽同理 << 的作用是 将/home/test/record-show.log 的内容追加到/home/test/record-new.log里面。

#### /dev/null
这条命令等同于 1>/dev/null，作用是将标准正确输出1重定向到/dev/null中。 /dev/null代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了>/dev/null之后，标准正确输出的内容就会不再存在，没有任何地方能够找到输出的内容。

#### 2>&1
这条命令用到了重定向绑定，采用&可以将两个输出绑定在一起。这条命令的作用是将标准错误输出和标准正确输出输出同用一个文件描述符，说人话就是标准错误输出和标准正确输出重定向到同一个地方

#### 比较一下（>/dev/null 2>&1 和 2>&1 >/dev/null）
上面提到了，linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令。那么我们同样从左到右地来分析2>&1 >/dev/null：

“2>&1”，将标准错误输出绑定到标准正确输出上。由于此时的标准正确输出是默认值，也就是重定向到屏幕上，所以此时标准错误输出会重定向到屏幕上。
“>/dev/null”，将标准正确输出1重定向到/dev/null中。
![[Pasted image 20221013153522.png]]

#### 比较一下（>/dev/null 2>&1 和 >/dev/null 2>/dev/null）
为什麽一定要用重定向绑定，而不是像>/dev/null 2>/dev/null这样子**分开来一遍呢**？现在我们尝试将标准正确输出和标准错误输出都定向到/home/test/record-to.log文件中：
![[Pasted image 20221013153701.png]]
我们看到指定文件接收到额内容并不正常，这是为啥呢？这是因为采用这种写法，标准正确输出和标准错误输出会抢占往/home/test/record-to.log文件的管道，所以可能会导致输出内容的时候出现缺失、覆盖等情况。**现在是出现了乱码，有时候也有可能出现只有error信息或者只有正常信息的情况。不管怎么说，采用这种写法，最后的情况是无法预估的。**



## 2 Shell工具和脚本

在本节课中，我们将介绍一些使用bash作为脚本语言的基础知识，以及一些shell工具，这些工具涵盖了你将在[命令行](https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4%E8%A1%8C&spm=1001.2101.3001.7020)中经常执行的几个最常见的任务。

## Shell脚本

到目前为止，我们已经看到了如何在shell中执行命令并将它们通过管道连接在一起。但是，在许多场景中，你将希望执行一系列命令，并使用控制流[表达式](https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020)(如条件或循环)。

Shell脚本是复杂性的下一步。大多数shell都有自己的脚本语言，其中包含变量、控制流和自己的语法。shell脚本与其他脚本编程语言的不同之处在于，它针对执行与shell相关的任务进行了优化。因此，在shell脚本中，创建命令管道、将结果保存到文件以及从标准输入读取都是基本的操作，这使得shell脚本比一般用途的脚本语言更容易使用。对于本节，我们将重点关注bash脚本，因为它是最常见的。

要在bash中分配变量，请使用语法`foo=bar`并使用`$foo`访问变量的值。请注意，`foo = bar`将不起作用，因为它被解释为使用参数`=`和`bar`调用`foo`程序。通常，在shell脚本中，空格字符将执行参数分割。这种行为刚开始使用时可能会让人感到困惑，所以一定要检查它。

bash中的字符串可以用`'`和`"`分隔符定义，但它们不相等。以`'`分隔的字符串是字面值字符串，不能替代变量值，而`"`分隔的字符串可以。
``` shell
foo=bar
echo "$foo"
# prints bar
echo '$foo'
# prints $foo

```
与大多数编程语言一样，bash支持控制流技术，包括`if`、`case`、`while`和`for`。类似地，bash也有接受参数的函数，可以对它们进行操作。下面是一个函数示例，它创建一个目录并使用`cd`进入其中。

```shell
mcd () {
    mkdir -p "$1"
    cd "$1"
}

```

这里`$1`是脚本/函数的第一个参数。与其他脚本语言不同，bash使用各种特殊变量来引用参数、错误代码和其他相关变量。以下是其中一些。更全面的列表可以在[这里](https://tldp.org/LDP/abs/html/special-chars.html)找到。

-   `$0` - 脚本名称
-   `$1` 到 `$9` - 脚本的参数。 `$1`是第一个参数，以此类推。
-   `$@` - 所有参数
-   `$#` - 参数的数量
-   `$?` - 上一条命令的返回状态码
-   `$$` - 当前脚本的进程标识号(PID)
-   `!!` - 最后一个命令，包括参数。一个常见的模式是只执行一个命令，因为它由于缺少权限而失败;通过`!! sudo`，你可以快速地重新执行sudo命令。
-   `$_` - 最后一个命令的最后一个参数。如果你在交互式shell中，也可以通过键入`Esc`后跟`.`或`Alt +`。

命令通常使用`STDOUT`返回输出，通过`STDERR`返回错误，并使用返回代码（Return Code）以更适合脚本的方式报告错误。返回代码或退出状态是脚本/命令必须用来传达执行情况的方式。值为0通常意味着一切正常;任何与0不同的值都意味着发生了错误。

退出码可用于使用&&(与运算符)和||(或运算符)有条件地执行命令，两者都是短路运算符。命令也可以用分号`;`分隔在同一行中。`true`程序的返回码总是0，而false命令的返回码总是1。让我们来看一些例子

```shell
false || echo "Oops, fail"
# Oops, fail

true || echo "Will not be printed"
#

true && echo "Things went well"
# Things went well

false && echo "Will not be printed"
#

true ; echo "This will always run"
# This will always run

false ; echo "This will always run"
# This will always run

```

另一个常见的模式是希望将命令的输出作为变量获取。这可以通过_命令替换_来完成。无论何时放置`$(CMD)`，它都会执行`CMD`，获得命令的输出并替换它。例如，如果你执行`for file in $(ls)`，shell将首先调用`ls`，然后迭代这些值。一个不太为人所知的类似功能是_进程替换_，`<( CMD )`将执行`CMD`并将输出放在临时文件中，并用该文件的名称替换<()。当命令希望通过文件而不是通过`STDIN`传递值时，这很有用。例如，`diff <(ls foo) <(ls bar)`将显示`foo`和`bar`目录中的文件之间的差异。

看完了上面一大堆文字，让我们来看一个展示这些特性的示例。它将遍历我们提供的参数，`grep`用于搜索字符串`foobar`，如果没有找到它，则将其作为注释追加到文件中。
```shell
#!/bin/bash

echo "Starting program at $(date)" # Date will be substituted

echo "Running program $0 with $# arguments with pid $$"

for file in "$@"; do
    grep foobar "$file" > /dev/null 2> /dev/null
    # When pattern is not found, grep has exit status 1
    # We redirect STDOUT and STDERR to a null register since we do not care about them
    if [[ $? -ne 0 ]]; then
    	# -ne:not equal
        echo "File $file does not have any foobar, adding one"
        echo "# foobar" >> "$file"
    fi
done

```

在比较中，我们测试了`$?`是否不等于0。Bash实现了许多此类比较-你可以在`test`的手册中找到详细列表。在bash中执行比较时，尽量使用双括号`[[]]`，而不是单括号`[]`。虽然不能移植到`sh`，但出错的几率更低。更详细的解释可以在[这里](http://mywiki.wooledge.org/BashFAQ/031)找到。

在启动脚本时，你通常想要提供相似的参数。Bash有一些方法可以简化这一点，通过执行文件名展开来展开表达式。这些技术通常被称为shell _globbing_。

-   通配符—当您想执行某种通配符匹配时，可以使用`?`和`*`分别匹配一个或任意数量的字符。例如，给定文件`foo`, `foo1`, `foo2`, `foo10`和`bar`，命令`rm foo?`将删除`foo1`和`foo2`，而`rm foo*`将删除除bar以外的所有内容。
-   花括号`{}`—当你在一系列命令中有一个公共子字符串时，您可以使用bash的花括号来自动展开它。这在移动或转换文件时非常方便。

```shell
convert image.{png,jpg}
# Will expand to
convert image.png image.jpg

cp /path/to/project/{foo,bar,baz}.sh /newpath
# Will expand to
cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath

# Globbing techniques can also be combined
mv *{.py,.sh} folder
# Will move all *.py and *.sh files


mkdir foo bar
# This creates files foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h
touch {foo,bar}/{a..h}
touch foo/x bar/y
# Show differences between files in foo and bar
diff <(ls foo) <(ls bar)
# Outputs
# < x
# ---
# > y

```


编写bash脚本可能很棘手，而且不直观。有一些像[shellcheck](https://github.com/koalaman/shellcheck)这样的工具可以帮助您查找sh/bash脚本中的错误。

注意，脚本不一定要用bash编写才能从终端调用。例如，下面是一个简单的Python脚本，它以相反的顺序输出参数:
```shell
#!/usr/local/bin/python
import sys
for arg in reversed(sys.argv[1:]):
    print(arg)

```

内核知道使用python解释器而不是shell命令来执行这个脚本，因为我们在脚本的顶部包含了shebang行。使用[env](https://www.man7.org/linux/man-pages/man1/env.1.html)命令编写shebang行是一个很好的实践，它将解析到命令在系统中的任何位置，从而提高脚本的可移植性。为了解析位置，`env`将使用我们在第一讲中介绍的PATH环境变量。对于本例，shebang行是 `#!/usr/bin/env python`这样。

shell函数和脚本之间的一些区别你应该记住:
-   函数必须使用与shell相同的语言，而脚本可以使用任何语言编写。这就是为什么要在脚本中引入shebang很重要的原因。
-   函数的定义被读取时加载一次。每次执行脚本时都会加载它们。这使得函数的加载速度稍微快一些，但无论何时更改它们，都必须重新加载它们的定义。
-   函数在当前shell环境中执行，而脚本在自己的进程中执行。因此，函数可以修改环境变量，例如更改当前目录，而脚本不能。脚本将通过使用[export](https://www.man7.org/linux/man-pages/man1/export.1p.html)导出的环境变量值传递
-   与任何编程语言一样，函数是实现模块化、代码重用和sell代码清晰性的强大构造。通常shell脚本会包含它们自己的函数定义。



检查shell脚本中的错误工具：shellcheck，有程序，也有插件

**查找帮助**： man 程序，但是输出太长，可以使用 `tldr 程序，输出几个例子（非常有用！）`

**查找文件**： find 和 fd ， fd 默认支持使用正则查找，更加符合直觉。 locate 使用数据库的方式更加快速的搜索，但是缺陷是只能通过文件名来查找。
```shell
# Find all directories named src
find . -name src -type d
# Find all python files that have a folder named test in their path
find . -path '*/test/*.py' -type f
	# Find all files modified in the last day
find . -mtime -1
	# Find all zip files with size in range 500k to 10M
find . -size +500k -size -10M -name '*.tar.gz'
```
**查找代码**： `grep` 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 -C ：`获取查找结果的上下文（Context）`；`-v `将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， grep -C 5 会输出匹配结果前后五行。`当需要搜索大量文件的时候，使用 -R 会递归地进入子目录并搜索所有的文本文件。`但是，我们有很多办法可以对 grep -R 进行改进，例如使其忽略.git 文件夹，使用多CPU等等。因此出现了很多替代品：比较常用的是 `ripgrep (rg)` ，因为它速度快，而且用法非常符合直觉。例子如下：

```shell
# 查找所有使用了 requests 库的文件
rg -t py 'import requests'
# 查找所有没有写 shebang 的文件（包含隐藏文件）
rg -u --files-without-match "^#!"
# 查找所有的foo字符串，并打印其之后的5行
rg foo -A 5
# 打印匹配的统计信息（匹配的行和文件的数量）
rg --stats PATTERN


```
**查找命令**
history 访问shell中输入的历史命令
对于大多数的shell来说，可以使用 Ctrl+R 对命令历史记录进行回溯搜索。敲 Ctrl+R 后可以输入子串来进行匹配，查找历史命令行。反复按下就会在所有搜索结果中循环。在 zsh中，使用方向键上或下也可以完成这项工作。

另一个我很喜欢的与历史相关的技巧是**基于历史的自动建议**。该特性首先由fish shell引入，它使用与当前shell命令共享一个公共前缀的最新命令动态地自动完成当前shell命令。它可以在zsh中启用，对于你的shell来说，这是一个提高生活质量的好方法。

你可以修改shell的历史行为，比如防止包含前导空格的命令。当你输入带有密码或其他敏感信息的命令时，这很方便。为此，添加`HISTCONTROL=ignorespace`到你的`.bashrc`或`setopt HIST_IGNORE_SPACE`到你的`.zshrc`。如果您犯了没有添加前导空格的错误，您总是可以通过编辑`.bash_history`或.`zhistory`手动删除条目
**导航**
ranger
autojump，命令 j
到目前为止，我们假设你已经到达了执行这些操作所需的位置。但是如何快速浏览目录呢?有许多简单的方法可以做到这一点，例如编写shell别名或创建带有`ln -s`的符号链接，但事实上，到目前为止，开发人员已经找到了相当聪明和复杂的解决方案。

与本课程的主题一样，您通常希望针对常见情况进行优化。查找频繁和/或最近的文件和目录可以通过快速和自动跳转等工具完成。`fasd`按频率对文件和目录进行排序，即按_频率_和_最近次数_进行排序。默认情况下，`fasd`添加了一个`z`命令，可以使用_frecent_目录的子字符串快速`cd`。例如，如果你经常访问`/home/user/files/cool_project`，你可以简单地使用`z cool`跳转到那里。使用`autojump`，可以使用`j cool`完成相同的目录更改。

有更复杂的工具可以快速地了解目录结构:`tree`、`broot`甚至是完全成熟的文件管理器，如`nnn`或`ranger`。