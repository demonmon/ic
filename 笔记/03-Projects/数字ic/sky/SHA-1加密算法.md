 - [ ] ![[Pasted image 20220917214543.png]]
## SHA-1算法原理
![[Pasted image 20220917215347.png]]


#### HA1的分组过程

对于任意长度的明文，
- 首先需要对明文添加位数，使明文总长度为448（mod512）位。在明文后添加位的方法是第一个添加位是l，其余都是0。
- **然后将真正明文的长度（没有添加位以前的明文长度）以64位表示**（最后两个w），附加于前面已添加过位的明文后，**此时的明文长度正好是512位的倍数**。
与MD5不同的是SHA1的原始报文长度不能超过2的64次方，另外SHA1的明文长度从低位开始填充。****
![[Pasted image 20220917215428.png]]

**「填充规则」**: 原始明文消息的`b`位之后补`100...`, 直到满足`（b + paddingLength） % 512 = 448`（这里是不包括添加了表示真正明文的长度）, 那如果`b % 512`在`[448, 512(0)]`之间呢，则**在增加一个分块，按照前面的规则填充即可**。（如下图）
![[Pasted image 20220917215637.png]]

对于任意长度的明文，SHA1首先对其进行分组，使得每一组的长度为512位，然后对这些明文分组反复重复处理。

对于每个明文分组的摘要生成过程如下：

（1） 将512位的明文分组划分为16个子明文分组，每个子明文分组为32位。

（2） 申请5个32位的链接变量，记为A、B、C、D、E。

（3） 16份子明文分组扩展为80份：u32 W[16]--->W[80]

（4） 80份子明文分组进行4轮运算。

（5） 链接变量与初始链接变量进行求和运算。

（6） 链接变量作为下一个明文分组的输入重复进行以上操作。

（7） 最后，5个链接变量里面的数据就是SHA1摘要。



**1.拓展明文**

```rust
H0 = 0x67452301
H1 = 0xEFCDAB89
H2 = 0x98BADCFE
H3 = 0x10325476
H4 = 0xC3D2E1F0
```

![[Pasted image 20220917221438.png]]

**2.明文四轮运算**

●  将A<<<5+ ft(B,C,D)+E+Wt+K[t]的结果赋值给链接变量A；
●  将链接变量A初始值赋值给链接变量B；
●  将链接变量B初始值循环左移30位赋值给链接变量C；
●  将链接变量C初始值赋值给链接变量D；
●  将链接变量D初始值赋值给链接变量E。
![[Pasted image 20220917220842.png]]
```text
TEMP = S^5(A) + f(t;B,C,D) + E + W(t) + K(t);
E = D;
D = C;
C = S^30(B);
B = A;
A = TEMP;
```

第四轮最后一个步骤的A，B，C，D，E输出，将分别与记录单元H0，H1，H2，H3，H4中的数值求和运算。其结果将作为输入成为下一个512位明文分组的链接变量A，B，C，D，E，当最后一个明文分组计算完成以后，A，B，C，D，E中的数据就是最后散列函数值。
即`H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E`
最后`H0~H4`即为最终**SHA-1的输出结果**。



其中`f`函数如下:

```text
f(t;B,C,D) = (B AND C) OR ((NOT B) AND D)         ( 0 <= t <= 19)
f(t;B,C,D) = B XOR C XOR D                        (20 <= t <= 39)
f(t;B,C,D) = (B AND C) OR (B AND D) OR (C AND D)  (40 <= t <= 59)
f(t;B,C,D) = B XOR C XOR D                        (60 <= t <= 79)
```
`k`函数如下:
```text
K(t) = 0x5A827999         ( 0 <= t <= 19)
K(t) = 0x6ED9EBA1         (20 <= t <= 39)
K(t) = 0x8F1BBCDC         (40 <= t <= 59)
K(t) = 0xCA62C1D6         (60 <= t <= 79)
```

![[Pasted image 20220917224311.png]]


![[Pasted image 20220917225130.png]]












![[Pasted image 20220917220210.png]]




每20轮一个变换函数 

![[Pasted image 20220917220929.png]]
![[Pasted image 20220917221154.png]]





![[Pasted image 20220917221702.png]]

Wt如何更新
![[Pasted image 20220918213145.png]]


 ![[Pasted image 20220917221846.png]]





![[Pasted image 20220917223319.png]]




 








![[Pasted image 20230821112835.png]]



## 算法模型建立

## HW架构设计


![[Pasted image 20220917230432.png]]


![[Pasted image 20220917230704.png]]
[(42条消息) 大端序和小端序_Casuall的博客-CSDN博客_大端序](https://blog.csdn.net/Casuall/article/details/98481469)
## RTL code代码编写

## test编写和RTL sim

## ....
