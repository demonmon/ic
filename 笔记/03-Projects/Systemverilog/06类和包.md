---
title: 第六周
updated: 2022-05-06 00:24:47
created: 2022-04-16 16:13:16
---
## 类的概述

> 类的三要素：类的封装、类的继承、类的多态

-   类是一种可以包含**数据**和**方法**（function，task）的类型。
-   例如一个数据包，可能被定义为一个类，类中可以包含指令、地址、队列ID、时间戳和数据等成员。
-   **packet**这个类可以在其中对这些数据做**初始化**，设置指令，读取该类的状态以及检查队列ID。
-   每一个packet类例化的具体对象其数据成员都可能不相同，然而**packet类作为描述这些数据的抽象类型**，**将其对应的数据成员和操作这些数据成员的方法都定义在其中**。

## 术语
-   类（class）：包含成员变量和成员方法。
-   对象（object）：类在例化后的实例。
-   句柄（handle）：指向对象的**指针**。
-   原型（prototype）：程序的声明部分，包含程序名、返回类型和参数列表。

## 构建函数
-   SV并不像C++语言一样要求复杂的存储空间开辟和销毁的而是采用了像Java一样空间自动开辟和回收的手段。
-   因此SV的类在定义时，只需要定义构建函数（constructor）而不需要定义析构函数（destructor）。当全局没有任何一个句柄指向它时类的空间就**自动释放**了
-   类在定义时，需要定义构建函数，如果未定义，则系统会自助定义一个空的构建函数new（）（没有形式参数，函数体亦为空）
-   对象在创建时（对象天然是动态的，仿真之后才有值），需要先声明再例化，同时进行亦可。

```systemverilog
class Packet_c
    interger command ;
    functionm new (int inival);//new函数没有返回值
    command = inival
endfunction 
endclass

module packet_m;
    interger command;
endmodule

typedef struct  {
    integer command;
} packet_s;

  module tb (
      packet_m m1(); //实例化
      initial  packet_m m2;//会报错
      packet_s s1 = '{1};
      initial  begin
          packet_s s2 = '{2};
          Packet_c c1;//称之为句柄
      end
      Packet_c c2 = new();//调用new函数才能开辟空间   
  endmodule
 //类，对象，句柄，对象是后台数据 通过句柄找到对象。
  //module 仿真开始之前已经例化 new不能在仿真开始之前执行
  //对象的创建只能在仿真以后执行
  module tb2 ;
  initial begin
      Packet_c c3;
     c3 = new(1);
  end
endmodule
```

## 静态成员（变量/方法）
-   类的成员（变量/方法）**默认都是动态**（automatic）生命周期，即每一个对象的变量和方法都会为其开辟新的空间。
-   如果多个对象为了共享一个成员（变量/方法），那么可以为其添加关键字**static**。
-   多个对象因此可以**共享同一个成员**变最或者方法。
-   访问该成员时，无需进行对象的例化。
-   成员方法也可以声明为静态
-   **静态的方法无法访问非静态成员**（变量/方法）否则会发生编译错误。
```systemverilog
class packet_c;      //类的声明
  integer command;
  static data;      //静态变量声明，静态变量在仿真前就开辟了空间
  function new(int inival);
    command = inival;    
  endfunction
endclass 

module tb3; 
packet_c cl, c2; 
initial begin: ini_proc
  $display("packet_c static data is 80d", packet_c::data); 
  c1=new(10); 
  $display("cl. command=80d, cl. data=80d", cl.command, cl.data); 
  c2=c1;      //
  $display("c2. command=80d,c2. data=80d",c2.command,c2.data); 
end 
endmodule 

/********************/

//静态成员，动态成员
//类默认都是动态成员，若要使用静态，static int data;
$display ("%0d ",Packet_c:data) ;//类用冒号索引
$display ("c1.data = %0d",c1.data);
/*c1没有创建对象是null 也能找到data，编译器会分析，
句柄指向的data是一个静态的变量 跑仿真的时候
data本来就是这个类，c1对应类型Packet_c
核心就是data不会存放到对象里面，data空间不在任何对象里
c1句柄指向这个类 而data就是静态变量 存放空间不在对象里面与创建对象与否无
编译器告诉我们data本来就是类 */
c1=new(10); //可以c1.data索引
module tb3;
Packet_c c1,c2;
initial begin
 //c1 = new();
//c2=c1; 这样还是一个对象，几个new几个对象，赋值的是句柄，不是对象
    $display("c1.command = %0d ",c1 ,c1.command);
    //c1.command 不能被索引到 没有分配空间，需要new
    $display("c2.command = %0d ",c2 ,c2.command);
end
endmodule


```

## this语句
-   this是用明确索引**当前所在对象**的成员（变量/参数/方法）
-   this**只可以用来在类的集静态成员、约束和覆盖组中使用**。
-   this的使用可以**明确**所指向变量的作用域。
```systemverilog
class Demo; 
integer x; 
  function new(integer x); 
    int x=3;
    this.x=x;         //若是没有使用this，则默认采用就近原则，寻找最近的成员变量（最好使用this）
  endfunction 
endclass
```

## 类的赋值和拷贝
-   **声明变量**和**创建对象**是两个过程，也可以一步完成。

> Packet p1;
 p1=new;

-   如果将p1赋值给另外一个变量p2，那么依然**只有一个对象**，是指向这个对象的句柄有p1和p2.
-   以下这种方式表示p1和p2代表两个不同的对象。在创建p2时，将从p1拷贝其成员变量例如integer、string和句柄等种拷贝方式称为**浅拷贝**（shallow copy）
```systemverilog
Packet pl；
Packet p2;
Packet p3;
p1 = new();      //只有经历过new函数才算生成一个对象
p3 = p1;         //句柄赋值，只有一个对象，但是有两条路寻找到（一个对象，两个句柄）
p2 = new p1;     //浅拷贝，两个对象，但只能拷贝对象的内容，如果里面有嵌套的对象内容无法复制（下层对象句柄可以）
```

### 深拷贝和浅拷贝的区别
-   **shadow copy**，是一种简易复制，类似于原对象的影印本，**只拷贝原对象的内容**，**不拷贝对象**（用new操作符）
-   如果类中包含一个指向另一个类的句柄，**那么只有高一级的对象（变量和句柄）被new复制**，下层的对象的内容不会被复制（但是下层对象的句柄可以被复制，即复制后，两个对象指向同一个低一级的对象！）
![[Pasted image 20220616125009.png]]

深拷贝：不仅拷贝句柄的值，会做递进式拷贝，增加对象空间
![image5](image5-6.png)


**deep copy**可将拷贝对象中所包含的对象拷贝过来（只能自定义copy函数，copy中需要调用new函数）
```systemverilog
class Transaction;
      bit [31:0] addr,crc,data[8];
      statistics stats;             //子对象
      static int count=0;
      int id;

      function new;
           stats=new();
           id=count++;
      endfunction

      function copy;   //深拷贝函数
          copy=new();
          copy.addr=addr;
          copy.data=data;
          copy.crc=crc;
          copy.stats=stats.copy();
          id=count++;
      endfunction               //将每一个量都拷贝一遍
endclass 

Transaction src, dst;
   initial begin
     src=new();
     src.stats.startT=42;
     dst=src.copy();
     dst.stats.startT=96;
     $display(src.stats.startT);
   end
```

参考：[SV中shadow copy和deep copy的区别](https://blog.csdn.net/yu1216338826/article/details/86551128)

## 数据的隐藏和封装
-   类的成员（变量/方法）默认情况下，即是**公共属性**的。这表示对于类自身和外部均可以访问该成员。
-   对于商业开发，类的提供方会**限制一些类成员的外部访问权限**，继而隐藏类成员的更多细节。
-   这种方式也使得类的外部访问接口更为**精简**，减轻了类的维护工作量，也使得类在修改时便于与旧版本保持兼容。
-   数据隐藏的方式使得类的测试和维护都变得更为简单。
-   对于成员的限定，如果使用**local**，则只有**该类可以访问此成员，而子类或者外部均无法访问**。
-   对于成员的限定，如果使用**protected**，则表示**该类和其子类均可以访问此成员，而外部无法访问**。
```systemverilog
class Packet; 
  local integer i; //只有该类可以访问此成员，而子类或者外部均无法访问  本地成员
  protected integer j;//该类和其子类均可以访问此成员，而外部无法访问   内部成员
  function integer compare (Packet other);
    compare=(this.i == other.i); 
  endfunction 
endclass
```

## 类的继承和子类
-   之前定义过的类Packet， 通过**extends**，LinkedPacket继承于其父类Packet，包括继承其**所有的成员**（变量/方法）

```systemverilog
class packet;
  integer i=1;      //例化对象时首先在这里开辟空间顺便赋初值（如果new中赋值，这里最好只声明）
  function new(int val);
    i=2;           //然后再运行new函数，覆盖初值
  endfunction 
  
  function shift()
    i=i<<2;
  endfunction
endclass 

class linkedpacked extends packet;   //子类可以继承父类所有的变量&方法，并可以进行增补
  //integer i=3;      //如果子类声明了i那优先索引的是子类的i
  function new();    //不管子类有没有new函数，都会先默认调用父类的new函数，如果子类有再执行自己的new函数
    super.new(val)   //如果父类new有参数，那么必须在子类的new中通过super.new(val)完成继承，如果父类没有参数，系统默认调用继承
    i=3;
  endfunction
  
  function shift()
    i=i<<2;
  endfunction
endclass 

module tb;
  initial begin 
    packetp=new(3);
    linkedpacked lp;            
    $display（"p.i=%0d"，p.i）;
    $display（"lp.i=%0d"，lp.i）;
    p.shift();
    $display（"after shift p.i=%0d"，p.i）;
    lp.shift();
    $display（"after shift ,lp.i=%0d"，lp.i）;
  end
endmodule
```

-   子类和父类存在重名变量或者函数，那调用子类的函数（如果没有使用`super`），子类如果没有才会调用父类的
-   子类执行new函数，必须先调用父类的new完成继承，如果父类new没参数，则可以自动完成调用，如果父类new函数有参数必须在子类的new中通过`super.new(val)`完成继承   
-   子类如果有相应的变量或函数那就调用自己的，没有的话就去父类找找。  
-   **子类成员优先级高于父类**，调用**this、super**则是明确调用域。但子类**必须通过new函数**继承父类。 
-   子类句柄赋值给父类句柄，**访问权限只有子类从父类继承的那一部分**。 
-   **父类的句柄不能赋值给子类的句柄**，因为父类较小，会有非法空间出现。
```systemverilog
packet p=new(3); 
linkedpacked lp=new(1); 
packet tmp; 
tmp=lp;   //子类句柄可以赋值给父类句柄，但句柄访问受限
```

- 子类继承父类所有成员,子类找不到new函数 会去查找父类new函数
只有new函数会默认调用，只要父类没有参数就会默认调用,new必须要完成一个继承
![image1](image1-13.png)

>写代码的好习惯：  
1、所有的类都要写new函数（哪怕为空）  
2、子类的new函数中，第一行先写上super.new()完成继承  
3、子类的变量不要和父类重名，方法可以  
4、在类中调用函数的时候最好写上this、super提高可读性  
5、在包、类等初始化的时候加上后缀如pkt_a

![image3](image3-9.png)

子父类都有i输出i=3,子类的i是3 父类的i是2,子类和父类会出现同名函数 super调用,子类变量和父类变量不要同名，，
子类句柄复制给父类句柄，父类句柄仍然指向子类对象 但访问的范围只有父类的范围。子类句柄不能找到父类的i（同名） 如果不同名就可以索引得到。
![[Pasted image 20220616130142.png]]


## 包的使用
-   为了便得可以在多个模块（硬件）或者类（软件）之间**共享用户定义的类型**，SV添加了包（package）Verilog没有包的概念。
-   包的概念参考于VHDL，用户自定义的类型譬如**类、方法、变量、结构体、枚举类**等都可以在package…..endpackage中定义。
```systemverilog
package pkg a;           //声明包a
  class packet_a; 
  endclass 
  typedef struct{
    int data; 
    int command;
  }struct a;
  int va=2;
endpackage 

package pkg_b;           //声明包b
  class packet_b; 
  endclass 
  typedef struct{
    int data;  
    int command;
  }struct b;
  int vb=3;
endpackage

module tb; 
  import pkg_a::packet_a;   //  导入包内的类
  import pkg_a::packet_a;
  import pkg_a::va;         //  导入包内的变量
  
  class packet_tb; 
  endclass 
  typedef struct{
    int data; 
    int command;
  } struct_tb; 
  
  initial begin 
    pkg_a::packet_a pa=new(); 
    pkg_b::packet_b pb=new();   //  初始化一个包，和例化类的对象不同需要声明域pkg_b::
    packet_tb  ptb=new();
    $display(pkg_b::vb)         //  直接通过域索引包内变量
  end endmodule
```

## 包的索引
-   方法一，直接通过域索引
```systemverilog
pkg_a::packet_a pa=new(); 
pkg_b::packet_b pb=new();    // 声明域pkg_b::索引包内的类
packet_tb  ptb=new();
$display(pkg_b::vb);         //  直接通过域索引包内变量
```

- 方法二，导入包中内容
```systemverilog
import pkg_a::packet_a;   //  导入包内的类
import pkg_a::packet_a;
import pkg_a::va;          //  导入包内的变量

import pkg_a::*;       //导入包内全部内容，编译器自己找
import pkg_a::*;       //但这这种 非精确查找优先级会很低，在编译器找不到的时候，才会考虑这两个包
```

package是将命名空间分隔开来，当使用不同package中的同名类，只需要注明是使用哪个package中的。
**只需要通过xxx_pkg :: 进行索引即可。**
**\`include的作用是把各个sv的代码复制到package中。**

**3.包和库的区分**

![image11](image11-4.png)

**4.包的命名规则  
**package以及其内部定义的类名称尽量加前缀。
这样的好处是不同package中定义的class也不同，在顶层的引用也**可以通过“import pkg_name :: \*”的形式，来表示在module mcdf_tb中引用的类**，如果在当前域（mcdf内部）中没有定义的话，会搜寻regs_pkg和arb_pkg的定义的类，又**由于它们各自包含的类名不相同，因此无需担心下面的搜寻会遇到同名类发生冲突的问题**。

**5.包的使用**


![image12](image12-4.png)
```systemverilog

```

















