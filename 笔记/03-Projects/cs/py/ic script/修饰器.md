> 业余解释：什么叫装饰器？顾名思义就是把函数包装一下，多层皮（功能），更好看（用）。

## 看一个例子

假设我们有下面的一个函数`func_a`。

```python
def func_a(s):
    print("Hello " + s)

func_a("bill")
```

如果需要对函数的输入参数进行预处理，比如把s的首字母大写，可以用下面的方式来实现。

```python
def func_a(s):
    print("Hello " + s)

#define a wrapper
def wrapper(func_a):
    def func_a_capital(s):
        s = s.capitalize()
        func_a(s)
    return func_a_capital

#use wrapper
func_a = wrapper(func_a)

func_a("bill")
# Hello Bill
```

先定义了一个函数`wrapper`，wrapper的参数是一个`函数名`，在python里函数也是对象，可以作为参数来传递。wrapper里又定义了另一个函数`func_a_capital`，`func_a_capticl`是一个局部函数，仅在wrapper里有效。但wrapper的返回值返回了这个内部函数，使得这个内部不会立即释放，从而在外部通过调用wrapper来取得`func_a_capital`的对象。

就是说wrapper(func_a)的返回值其实就是`func_a_captial`，我们再`func_a = wrapper(func_a)`，这样就把func_a指向了新定义的函数`func_a_capital`。

在`func_a_capital`里，我们实现了首字母大写的扩展，并调用了原先的`func_a`。

可以看到，我们在**不修改`func_a`的前提下，顺利扩展了`func_a`的功能**。这就是所谓的装饰。

对于`func_a = wrapper(func_a)`通常使用一种简写方式`@wrapper`，改进后的代码如下：

```python
#define a wrapper
def wrapper(func_a):
    def func_a_capital(s):
        s = s.capitalize()
        func_a(s)
    return func_a_capital

#use wrapper with a simple way
@wrapper
def func_a(s):
    print("Hello " + s)

func_a("bill")
# Hello Bill
```

从运行结果也可以确认效果与上一段代码相同。

## 总结

今天用一个简单的例子介绍了函数的装饰器。要正确理解这个功能，只需要记住一点：**函数也是对象，函数名就是指向对象的指针（句柄），可以作为函数的参数或者返回值**。





