---
title: Calc_smpl
updated: 2022-05-06T19:08:35.0000000+08:00
created: 2022-03-25T16:00:15.0000000+08:00
---

ECC 算法中有两个常量： **bigHexP256 是一个 256 位常量**。密钥
bigHexP256 = {0xFFFFFFFF，0x1，0x0，0x0，0x0，0xFFFFFFFF，0xFFFFFFFF，0xFFFFFFFF};
point_at_inifnity是一个三维向量常数。 point_at_infinity.x = 0; point_at_infinity.y = 1;point_at_infinity.z = 0;
![image1](image1-23.png)

calc_smpl执行由 ecc 算法调用的简单计算。简单的计算包括添加两个256位数据，减去两个256位数据，乘以256位数据的3/2/4/8。所有简单的计算都是在有限场上计算的，结果是按常数修改的（第3.1章中的bigHexP256）。
所有计算都是在32位数据上完成的。
对于A + B的计算，因为A\<bigHexP256和B\<bigHexP256，然后是A + B\<2 \* bigHexP256。因此计算如下：C = A + B并将C与bigHexP256进行比较 如果C>bigHexP256，则C = C- bigHexP256
对于A \*3的计算，因为A\< bigHexP256，然后是A \*3\<3\* bigHexP256。如果 A\*3>2 bigHexP256，则 A>2\* bigHexP256/3 表示 A\[255\]=1。因此，计算如下：
如果 A\[255\]==1，则 C=A+2A- bigHexP256，否则 C=A+2A
如果 C> bigHexP256，则 C=C- bigHexP256

对于 A\*2、A\*4 和 A\*8 的计算，计算结果实际上是 A\<\<N，N 等于 1、2 和 3。计算如下：
如果 A\[255：256-N\]！=0，则 **C=A\<\<N- bigHexP256\* A\[255：256-N\]**。因为 bigHexP256 是一个非常特殊的数字，所以 bigHexP256\* A\[255：256-N\] 可以很容易地计算出来。让 D 表示 A\[ 255：256-N\]，那么**bigHexP256\*D** 是： {D-1，0x100000000-D，D，0x0，0x0，D-1，0xFFFFFFFF，0xFFFFFFFF，0x100000000-D}
如果 C> bigHexP256，那么 **C=C- bigHexP256**

**

![image2](image2-19.png)

空闲：空闲状态
GET8：获取数据 D，以便使用一个输入进行计算
DBLE：使用两个数据输入（A + B和A-B）进行计算
SNGL：使用一个数据输入进行计算（A \* N-D \* bigHexP256或C- bigHexP256）
TAIL：由于流水线阶段，最后几个周期进行计算。
A：calc_smpl的开始，当前计算为A + B或A-B
B：calc_smpl的开始，当前计算为A + B和A-B
C：两个时钟周期
D：24 个时钟周期
E：16 个时钟周期
F：3 个时钟周期，但仍需要使用 bigHexP256 再加法或减法
G：3 个时钟周期，结果在 0 到 bigHexP256 的范围内

DBLE： Fsm_cntc2 将数据传入b，fsm_cntc \_1 将数据传入a ， cntc2=0时，cntc加1 否则cntc＋1，下一个周期就会传入b，在cntc 2高有效，cnta计数8，再跳转TAIL。也就是cnta计数到2时，cntc才计数一次。
TAIL

![image3](image3-17.png)
mod512 计算 mult256 结果的 mod。mod512的输入数据是一个512位数字，存储在内部存储器的最低地址。在计算过程中，温度结果也存储在内部存储器的最低地址中，该地址将与原始输入数据重叠。计算与除法相同。

IDLE（0）：空闲状态
CMP（1）：将最高的256位与bigHexP256进行比较，并将最高的32位数据与零进行比较
CMP_T--2：由于流水线，CMP 状态需要多几个时钟周期
COPY--3：从输入数据复制到结果地址
COPY_T--4：由于流水线原因，COPY状态需要多几个时钟周期，并在必要时将零写入结果地址的高位
SUB--5：从输入数据中分出 bigHexP256
SUB_T--6：由于流水线，SUB 状态需要再多几个时钟周期

A：开始启用
B：当所有8个32位数据读取请求全部发送到存储器时，无法判断内部存储器最低地址中的当前数据与bigHexP256之间的关系
C：内部存储器最低地址的当前数据小于bigHexP256。
D：内部存储器最低地址的当前数据大于bigHexP256。
E：内部存储器最低地址的当前数据小于bigHexP256。
F：内部存储器最低地址的当前数据大于bigHexP256。
G：已读取内部存储器最低地址中剩余的数据
H：所有结果数据都已写入结果地址
I：16 个时钟周期
J：3个时钟周期和减法结果大于bigHexP256，或3个时钟周期和减法结果小于bigHexP256，减法结果的最高32位不为零，剩余数据长度大于256
K：3个时钟周期，减法结果小于bigHexP256，减法结果的最高32位为零，剩余数据长度大于256
L：3个时钟周期，减法结果小于bigHexP256，剩余数据长度小于256

点加与倍点运算模块的实现思路是，把点加与倍点运算分解成一
系列的底层运算，然后编译成指令由硬件执行。

![image4](image4-14.png)

IDLE（0）：空闲状态
GETA（01）：从输入数据 A 获取 32 位数据
CALC（10）：计算一个256位数据（B）和一个32位数据的乘法，乘法结果加到上一个结果中
TAIL（11）：由于流水线阶段，最后几个周期进行计算。
A：开始启用
B：3 个时钟周期
C：24个时钟周期，当前不是来自输入数据A的最后32位数据
D：24个时钟周期和当前是来自输入数据A的最后32位数据
E：3 个时钟周期
乘法控制模块为乘法处理模块准备计算的数据， 实现时将其中一个 256 比特
乘数 X 按照 32 比特长度进行分段，共分为 X7， X6， X5， X4， X3， X2， X1， X0 八段，
每循环一次送 1 段数据到乘法处理模块。 乘法控制模块共有八次循环， 第一次循
环将 X0 送给乘法处理模块，第二次循环将 X1 送给乘法处理模块， 以此类推，第八
次循环将 X7 送给乘法处理模块。 每次循环等到乘法处理模块运算完成后，才进行
下一次循环

![image5](image5-13.png)

Ecc.reg
ecc_reg通过APB接口与MCU通信。ecc的所有控制寄存器都在ecc_reg中实现。如有必要，ecc_reg还会为系统生成中断

jcbdble
![image6](image6-11.png)

空闲：空闲状态 CMP：将输入数据的坐标 Y 与零进行比较 SET：设置point_at_inifnity输入数据的地址 RUN：9.3 中描述的计算 A：开始启用 B：Y 不为零 C：Y 为零 D：工艺完成
*\>*
