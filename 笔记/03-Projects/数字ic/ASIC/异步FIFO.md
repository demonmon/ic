## 异步FIFO

### 异步FIFO的一般结构
- 双端口RAM：用于存储效据。
- 读控制逻辑：控制读操作与空信号（ empty）的判断与产生，属于读时钟域。
- 写控制逻辑：控制写操作与满信号（wfull)的判断与产生，属于写时钟域。
- 二进制码与格雷码转换模块：用于将读写地址二进制码转成格雷码。
- 跨时钟同步模块：将读地址的格雷码与wclk同步；将写地址的格雷码与rclk同步。

### 异步FIFO处理的核心问题
-   FIFO深度的计算。
-   读写地址的编码
-   控制信号、读写地址的跨时钟域同步
-   读写控制信号的产生。


## 异步FIFO关键技术1 -- 读写信号跨时钟域同步

首先，FIFO的关键是需要判断读空和写满，而这两个信号的产生依赖读地址和写地址。在异步FIFO中，读和写是分在两个时钟域中的，在写时钟域，需要得到读地址的信息进而判断是否写满（写指针是否追上读指针），同理，在读时钟域，也需要写地址的信息。我们知道跨时钟域的单比特数据一般可以用双寄存器法进行同步，但读写地址通常都是多比特的信号，此时如何进行同步呢？

当然，多比特的同步肯定可以通过增加握手信号来解决，但实际上对于数值上连续的信号，可以采用格雷码进行多比特到单比特的传输。格雷码再次不做介绍，具体原理可以参考：[https://www.cnblogs.com/zhuruibi/p/8988044.html](https://www.cnblogs.com/zhuruibi/p/8988044.html)

有了格雷码，就可以将读写地址同步到各自的时钟域了。因为有了格雷码使得相邻变化只有1bit。因此多比特变化转化为单比特变化。如果写时钟频率过快，使得上次采样的格雷码和此时采样的格雷码并不是相邻的，但是格雷码变化还是从他的上一个地址跳到这一地址，也就是说，其他位已经保持稳定了。
例如上次采样是3 这次采到的是6，但是并没有发生多比特变化，因为并不是直接从3变化到6，采样6的时候是从5变化到6，5到6只有第二位发生变化，其他三位在采样时钟来的时候已经稳定了。


![[Pasted image 20220724153712.png]]


## 异步FIFO关键技术2 -- 读写地址的比较

跟普通fifo一样，异步fifo也是通过比较读写地址是否相同来判断当前fifo是否空满。区别在于，异步FIFO因为使用了格雷码对地址进行编码传输。比如读信号通过格雷码编码后同步到写时钟域，此时需要只需要写信号对应的格雷码和读信号格雷码是否相同（有效位相同）。而在这个比较时会又一些问题。
![[Pasted image 20220724154006.png]]
通常FIFO为了防止读写溢出，一般都会增加一个额外的MSB，例如上图中，实际上深度为8的fifo只需要3位地址位表示，增加的额外的一个bit是为了区分读写是**否经过了一次“回卷**”。在二进制中表示的地址中，空满信号实际上是先看MSB是否相同，再看低3比特是否相同。如果都相同，表示读空，即读地址赶上了写地址。如果MSB不同，低3位相同，则表示写满。在二进制空间这个逻辑没问题。

而到了格雷码中，从上图中可以发现，假设读地址为0，写地址为7。当写地址再加1时，写地址溢出，MSB变为1，实际上表示写地址又回到了0的位置，MSB表示多了一圈。但是对应的格雷码确实**最高的两位都发生了变化。** 从上图可以发现，格雷码中写地址发生回卷后，也就是对应二进制的MSB发生变化后，其最高两位恰好是不回卷时的反。因此只要将读地址的格雷码最高两位进行翻转后再跟写地址比较即可得到正确的满信号。

![[Pasted image 20220724154139.png]]


[[异步FIFO]] 不会有满了继续写，空了继续读的情况。因为他们判断满和空都是悲观的情况。例如判断空，需要把写地址同步过来在比较，当同步过来时，此时的实际写地址要比同步过来的要大，也就是说你读地址连同步过来的写地址都追不上，实际的更追不上（实际地址要大于等于）。如果判断满，你需要吧读地址同步到写时钟域，而同步过来那一时刻，实际的读地址要比同步过来的大，我们需要判断写地址有没有追上读，如果连同步过来的读地址都没有追上，那就更追不上实际的读地址，是一种消极判断。也就是说只能会判断假空假满。会浪费其性能
